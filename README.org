# -*- mode: org; coding: utf-8; fill-column: 72; -*-
#+TITLE: Adam Liter's computer configuration
#+AUTHOR: Adam Liter
#+EMAIL: io@adamliter.org

#+LANGUAGE: en
#+TOC: headlines 1
#+STARTUP: fold

* New machine setup

** SSH
:PROPERTIES:
:header-args:sh: :eval no
:header-args:conf-space: :eval no
:END:

The first thing that must be done in order to set up a new machine is to
configure SSH and create a key. This allows for cloning of [[conf][the =git=
repo that contains my configuration files]], which is hosted on GitHub.

First, create the SSH directory:

#+begin_src sh
mkdir -p ~/.ssh
chmod 700 ~/.ssh
#+end_src

Optionally, I can also set up an =authorized_keys= file, which is useful
if the new machine is intended to be used as a server in any capacity.

#+begin_src sh
touch ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys
#+end_src

Next, I need to actually create a new SSH key, which can be done with:

#+begin_src sh
ssh-keygen -t rsa -b 4096 -C "COMMENT GOES HERE"
#+end_src

Then, I can set up a basic SSH configuration file to ensure that the key
that I just generated is used when trying to connect to GitHub as well
as my private =git= server, which contains some of the submodules in
this repository. (Note that this basic SSH configuration file will be
overwritten later in this new machine configuration process.)

This allows repositories to be cloned in either of the following manners:

1. ~git clone ssh://github/adamliter/conf.git~
2. ~git clone github:adamliter/conf.git~

#+begin_src conf-space
cat > ~/.ssh/config <<EOF
Host github
  Hostname github.com
  IdentityFile ~/.ssh/id_rsa
  User git

Host git-adamliter
  Hostname git.adamliter.org
  IdentityFile ~/.ssh/id_rsa
  User git
EOF
chmod 600 ~/.ssh/config
#+end_src

Finally, the public key needs to be added to GitHub and to
~/home/git/.ssh/authorized_keys~ on the machine ~git.adamliter.org~. (It
will also eventually need to be added to GitLab and Bitbucket.)

** Bootstrapping
:PROPERTIES:
:header-args:sh: :eval no
:END:

To bootstrap the setup of a new machine, use the =bootstrap.sh= script,
described [[bootstrap-script-explanation][below]]. It can be downloaded from GitHub with either ~curl~ or
~wget~:

With ~curl~:

#+begin_src sh
curl -fsSL https://raw.githubusercontent.com/adamliter/conf/master/bootstrap.sh | bash -v
#+end_src

With ~wget~:

#+begin_src sh
wget -O- https://raw.githubusercontent.com/adamliter/conf/master/bootstrap.sh | bash -v
#+end_src

*** =bootstrap.sh=
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

This section defines a [[https://raw.githubusercontent.com/adamliter/conf/master/bootstrap.sh][bootstrap script]] for installing Homebrew, Emacs,
Doom Emacs, and a variety of other things.

That script is written to this repository when this file is tangled. The
output of the tangling is not ignored by version control even though it
is a derived file because tracking it allows a ~curl~-able version of
the file to exist on GitHub for bootstrapping the setup of a new
machine.

The first thing the script does is set some flags for exiting and
debugging:

#+begin_src sh
# -*- coding: utf-8; mode: sh; -*-
# Exit when a command fails
set -o errexit
# Exit when a command in a series of pipes fails
set -o pipefail
# Exit when there is an undeclared variable
set -o nounset
# Trace what gets executed (for debugging)
#set -o xtrace
#+end_src

Let's run the rest of the script from the home directory:

#+begin_src sh
cd "${HOME}"
#+end_src

# TODO: prevent this script from running if ~/conf exists and either
# the working tree is not clean in the repository itself or any of its
# submodules or there are any references that aren't tracked in the
# remote version of the repository

Next, let's have the script detect the operating system, including
whether it's a Mac with an Intel chip or an Apple silicon chip.

#+begin_src sh
if [[ $OSTYPE == darwin* ]]; then
    BASH_OS_TYPE='macOS'
elif [[ $OSTYPE == linux-gnu ]]; then
    BASH_OS_TYPE='Linux'
    echo "This bootstrapping script does not currently support Linux ..."
    exit 1
elif [[ '$OS' == Windows* ]]; then
    BASH_OS_TYPE='Windows'
    echo "This bootstrapping script does not currently support Windows ..."
    exit 1
else
    BASH_OS_TYPE='Unknown'
    echo "Unknown operating system ..."
    exit 1
fi

if [[ $BASH_OS_TYPE == 'macOS' ]]; then
    if [[ $(uname -m) == arm* ]]; then
        MAC_OS_TYPE='apple-silicon'
    elif [[ $(uname -m) == x86_64 ]]; then
        MAC_OS_TYPE='intel'
    else
        MAC_OS_TYPE='Unknown'
    fi
fi
#+end_src

**** Homebrew

Let's install Homebrew as a package manager.

#+begin_src sh
if [[ $BASH_OS_TYPE == macOS ]]; then
    if type brew >/dev/null 2>&1; then
        echo "Homebrew is already installed ..."
    else
        echo "Installing Homebrew ..."
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
        echo "Homebrew was successfully installed ..."
        if [[ $MAC_OS_TYPE == 'apple-silicon' ]]; then
            echo "Temporarily adding Homebrew to PATH for Apple Silicon Mac ..."
            eval $(/opt/homebrew/bin/brew shellenv)
        fi
        echo "Tapping ralwaycat/emacsport ..."
        brew tap railwaycat/emacsmacport
    fi
fi
#+end_src

**** =${HOME}/conf=

Next, the script clones [[https://github.com/adamliter/conf][the repository that contains my configuration
files]] into =${HOME}/conf=. If that directory already exists, the ~git
clone~ command will fail, so I remove it first just to be cautious, but
this should be unnecessary if this is a new machine.

If this is not a new machine, the command ~rm -rf "${HOME}/conf"~ will
remove the file =~/.ssh/config=, since that file is a symlink that
points inside of the =git= repository. This will cause the
=bootstrap.sh= script to fail since the submodules in the repository
make use of the SSH hosts defined in the SSH config file. Thus, in order
to ensure that this =bootstrap.sh= script can also be run on a machine
that is already setup (to, for example, reset how everything is
configured or apply new changes), we want to ensure that those SSH hosts
still exist when this script tries to clone the repo and its submodules.

#+begin_src sh
if [ -f "${HOME}/.ssh/config" ]; then
    cp -H "${HOME}/.ssh/config" "${HOME}/.ssh/config.temp"
    rm "${HOME}/.ssh/config"
    mv "${HOME}/.ssh/config.temp" "${HOME}/.ssh/config"
fi
if [ -d "${HOME}/conf" ]; then
    echo "~/conf already exists; backing it up to ~/conf.bkp ..."
    cp -r "${HOME}/conf" "${HOME}/conf.bkp"
fi
rm -rf "${HOME}/conf"
git clone github:adamliter/conf.git "${HOME}/conf"
#+end_src

After cloning, it updates all submodules. Submodules, as always, are a
bit tricky. ~git submodule update --init --recursive~ will recursively
initialize and update all submodules in the =git= repo. Moreover, with
the ~--remote~ flag, any submodules that are specified to track a branch
on the remote will be fast-forwarded to the most recent commit on that
branch on the remote, regardless of the status of the submodule in the
parent repo. Furthermore, since [[https://stackoverflow.com/a/20797186/2571049][submodules are always checked out in a
detached HEAD state]], the script also checks out either the branch that
the submodule is set up to track on the remote or the =main= branch for
all submodules.

#+begin_src sh
cd "${HOME}/conf"
git submodule update --init --remote --recursive

git submodule foreach --recursive \
  'git checkout \
  $(git config -f $toplevel/.gitmodules submodule.$name.branch || \
  echo main)'

cd "${HOME}"
#+end_src

**** XCode command line tools

#+begin_src sh
if [[ $BASH_OS_TYPE == macOS ]]; then
    if xcode-select -p >/dev/null 2>&1; then
        echo "XCode command line tools are already installed ..."
    else
        echo "Installing XCode command line tools ..."
        xcode-select --install
    fi
fi
#+end_src

**** Emacs

#+begin_src sh
if [[ $BASH_OS_TYPE == macOS ]]; then
    if ([[ $MAC_OS_TYPE == 'apple-silicon' ]] && [ -f /opt/homebrew/bin/emacs ]) \
        || ([[ $MAC_OS_TYPE == 'intel' ]] && [ -f /usr/local/bin/emacs ]); then
       echo "Emacs was already installed with Homebrew ..."
    else
        echo "Installing Emacs ..."
        brew install emacs-mac  --with-emacs-big-sur-icon --with-imagemagick \
            --with-natural-title-bar --with-native-compilation \
            --with-mac-metal --with-unlimited-select --with-tree-sitter
    fi
fi
#+end_src

**** Doom Emacs

First, let's symlink =.doom.d= into place:

#+begin_src sh
rm -rf "${HOME}/.doom.d"
ln -sn "${HOME}/conf/doom.d" "${HOME}/.doom.d"
#+end_src

Next, let's install the dependencies for Doom Emacs:

#+begin_src sh
if ~/.emacs.d/bin/doom >/dev/null 2>&1; then
    echo "Doom Emacs is arleady installed ..."
else
    echo "Installing dependencies for Doom Emacs ..."
    if [[ $BASH_OS_TYPE == macOS ]]; then
        brew install git ripgrep
    fi
    echo "Installing optional dependencies for Doom Emacs ..."
    if [[ $BASH_OS_TYPE == macOS ]]; then
        brew install coreutils fd
    fi
    echo "Cloning the doomemacs repository ..."
    git clone https://github.com/doomemacs/doomemacs ~/.emacs.d
    echo "Installing Doom Emacs ..."
    ~/.emacs.d/bin/doom install
fi
#+end_src

**** Tangle away

Next, the script evaluates all source code blocks in the file
=${HOME}/conf/README.org= where ~:eval yes~ as well as tangling the file
in order to put all other configuration information in the proper
locations.

#+begin_src sh
emacs --batch \
  --eval="(progn
  (require 'org)
  (setq org-confirm-babel-evaluate nil)
  (find-file \"~/conf/README.org\")
  (org-babel-tangle)
  (org-babel-execute-buffer)
  (kill-buffer))"

#+end_src

**** Symlinks

Finally, the script sources a separate =symlink.sh= which symlinks most
things into place (the exceptions are that =bootstrap.sh= does the
symlinking for the submodules of this repository). The symlinking is
separated out into its own script so that I can just run the
=symlink.sh= script on a Linux machine where I don't want to install
anything, but I do want, for example, my Bash configuration set up in
the same way that it is set up on my personal machine. The use case for
this is on the [[https://wiki.glassdoor.com/display/EB/New+Machine+Learning+Nodes][Machine Learning Nodes]].

#+begin_src sh
. "${HOME}/conf/symlink.sh"
#+end_src

* Command line utilities

This section of this =org= document both installs the relevant command
line utility (if it is not already installed) and creates the
appropriate configuration files for that utility, if necessary. Even
though all of the configuration files are derived files, they are all
kept under version control and symlinked into the appropriate
locations. Doing so allows me to more readily notice any external
programs or utilities that change my configuration files, as it will
lead to a dirty working tree in =git=.

** aspell

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install aspell
#+end_src

*** Configuration

** bash

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

The version of bash that ships on macOS is pretty outdated, so let's
install a more recent version via Homebrew. In order to use this newer
version of bash as the login shell, it needs to be added to the file
=/etc/shells=. Then, the shell can be changed to the new bash version
for the current user. In order for this to take effect, I log back in.

#+begin_src sh
if [[ $BASH_OS_TYPE == macOS ]]; then
    brew install bash
    if ([[ $MAC_OS_TYPE == 'apple-silicon' ]] && ! grep -q "/opt/homebrew/bin/bash" /etc/shells) \
        || ([[ $MAC_OS_TYPE == 'intel' ]] && ! grep -q "/usr/local/bin/bash" /etc/shells); then
        echo "Adding Homebrew's bash to possible login shells ..."
        if [[ $MAC_OS_TYPE == 'apple-silicon' ]]; then
            sudo bash -c "echo /opt/homebrew/bin/bash >> /etc/shells"
        fi
        if [[ $MAC_OS_TYPE == 'intel' ]]; then
            sudo bash -c "echo /usr/local/bin/bash >> /etc/shells"
        fi
    else
        echo "Homebrew's bash is already a possible login shell ..."
    fi
    if ([[ $MAC_OS_TYPE == 'apple-silicon' ]] && [ $SHELL == "/opt/homebrew/bin/bash" ]) \
        || ([[ $MAC_OS_TYPE == 'intel' ]] && [ $SHELL == "/usr/local/bin/bash" ]); then
        echo "Shell is already set to Homebrew's bash ..."
    else
        echo "Setting shell to Homebrew's bash ..."
        if [[ $MAC_OS_TYPE == 'apple-silicon' ]]; then
            chsh -s /opt/homebrew/bin/bash
        fi
        if [[ $MAC_OS_TYPE == 'intel' ]]; then
            chsh -s /usr/local/bin/bash
        fi
    fi
fi
#+end_src

*** Configuration

References:

- [[https://superuser.com/q/183870/756208][Difference between .bashrc and .bash_profile]]
- [[https://superuser.com/q/789448/756208][Choosing between .bashrc, .profile, .bash_profile, etc]]

**** =~/.bash_profile=
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle ~/conf/bash/bash_profile :mkdirp yes :padline no
:END:

Login shells (/e.g./ a shell that you start from a non-graphical desktop
environment, like when logging into a machine via SSH) read one of three
files (assuming your shell is bash):

1. =~/.bash_profile=
2. =~/.bash_login=
3. =~/.profile=

Whichever file is found first is the one that gets read, and the shell
stops looking for the others. Furthermore, login shells do *not* read
=~/.bashrc=, but the best practice is to have an *interactive* login
shell read =~/.bashrc=. Ensuring that this happens is done by adding the
following to the =~/.bash_profile= file:

#+begin_src sh
# -*- mode: sh; fill-column: 72; coding: utf-8 -*-
if [ -f "${HOME}/.bashrc" ] && [[ $- == *i* ]]; then
    source "${HOME}/.bashrc"
fi
#+end_src

It's worth noting that on macOS, unlike on Linux, all shells started
from Terminal.app (or iTerm.app) in a graphical environment are started
as login shells and thus read =~/.bash_profile= (instead of =~/.bashrc=,
which is what is read when starting Terminal in a graphical desktop
environment on Linux, since it is a non-login shell). Thus, if you want
anything in your =~/.bashrc= to be read when using macOS, you certainly
need to make sure that =~/.bash_profile= sources =~/.bashrc=.

At any rate, this can now be symlinked into the appropriate location,
after it is tangled:

#+begin_src sh :eval no :exports code :tangle symlink.sh :shebang "#!/usr/bin/env bash" :padline no
ln -sf "${HOME}/conf/bash/bash_profile" "${HOME}/.bash_profile"
#+end_src

**** =~/.bashrc=
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle ~/conf/bash/bashrc :mkdirp yes :padline no
:END:

In the =~/.bashrc= file, I want to ensure that the system-wide =bashrc=
file is read, if it exists. On macOS, this usually exists as
=/etc/bashrc=.

#+begin_src sh
if [ -f /etc/bashrc ]; then
    source /etc/bashrc
fi
#+end_src

And, on Ubuntu, this usually exists as =/etc/bash.bashrc=.

#+begin_src sh
if [ -f /etc/bash.bashrc ]; then
    source /etc/bash.bashrc
fi
#+end_src

While it is not considered best practice to source =~/.profile= from
inside of =~/.bashrc= (in particular, see [[https://superuser.com/a/183980/756208][Gilles's answer]] to [[https://superuser.com/q/183870/756208][Difference
between .bashrc and .bash_profile]]), I'm going to go ahead and do this
anyway because it makes life easier, and I have yet to encounter any
problems because of it. The recommended best practice is to source
=~/.basrhc= and =~/.profile= from =~/.bash_profile=, in that
order. However, for the reasons mentioned above when discussing macOS
shells started in the graphical desktop environment, most shells started
in a graphical desktop environment will only read =~/.bashrc= because
they are non-login shells. However, this means that environment
variables that are set in =~/.profile= will not be available in these
shells. So I'll flout the best practice for now, until I run into
problems because of it.

#+begin_src sh
if [ -f "${HOME}/.profile" ]; then
    source "${HOME}/.profile"
fi
#+end_src

***** Aliases

Sometimes you just need to shrug:

#+begin_src sh
alias eh="echo ¯\\\_\(ツ\)_/¯ | pbcopy"
alias ehh="eh"
#+end_src

Some aliases for changing directories:

#+begin_src sh
alias .1='cd ..'
alias ..='cd ..'
alias .2='cd ../..'
alias ....='cd ../..'
alias .3='cd ../../..'
alias .4='cd ../../../..'
alias .5='cd ../../../../..'
#+end_src

List all the things:

#+begin_src sh
alias l='ls -aF'
alias ll='ls -alF'

# list only hidden directories and files
alias l.='ls -dF .*'
alias ll.'=ls -ldF .*'
#+end_src

To ensure the availability of 256 colors in =tmux= (see [[https://stackoverflow.com/a/10163861/2571049][this answer]] to
[[https://stackoverflow.com/q/10158508/2571049][lose vim colorscheme in tmux mode]]).

#+begin_src sh
alias tmux='tmux -2'
#+end_src

Some macOS-specific aliases:

#+begin_src sh
if [[ $OSTYPE == darwin* ]]; then
    alias showFiles='defaults write com.apple.finder AppleShowAllFiles \
YES; killall Finder'
    alias hideFiles='defaults write com.apple.finder AppleShowAllFiles NO; \
killall Finder'
fi
#+end_src

An SSH alias for =ssh-add=:

#+begin_src sh
alias sshid='ssh-add ~/.ssh/id_rsa'
#+end_src

Some aliases for =pass=:

#+begin_src sh
alias ppass='PASSWORD_STORE_DIR=~/.password-store/personal/ pass'
alias pp='ppass'

# lingbib password store
alias lb-pass='PASSWORD_STORE_DIR=~/.password-store/shared-projects\
/lingbib/ pass'

# common logins
alias amazon='pp -c misc/amazon'
alias amex='pp -c finances/amex'
alias bb='pp -c misc/bitbucket'
alias chess='pp -c misc/chess'
alias dl='pp -c travel/delta'
alias fmail='pp -c email/fastmail/password'
alias kb='pp -c keybase/passphrase'
alias msufcu='pp -c finances/msufcu'
#+end_src

Some aliases for =git= and =hub=:

#+begin_src sh
if type hub >/dev/null 2>&1; then
    alias git='hub'
fi
alias g='git status -sb'
alias gp='git pull'
alias gpr='git pull --rebase'
alias gpp='git pull --rebase && git push'
alias ga='git add'
alias gc='git commit'
alias gcn='git commit --no-edit'
alias gce='git commit -e'
alias gces='git commit -eS'
alias gca='git commit --amend'
alias gcah='git commit --amend -C HEAD'
alias gcv='git commit --no-verify'
alias gdv='git diff'
alias gdc='git diff --cached'
alias gl='git log --oneline --decorate --graph'
alias gla='git log --oneline --decorate --graph --all'
alias gt='git tag'
alias grc='git rebase --continue'
alias gsl='git stash list'
alias gss='git stash save'
#+end_src

And an alias for =kubectl=:

#+begin_src sh
if command -v kubectl 1>/dev/null 2>&1; then
    alias k='kubectl'
fi
#+end_src

***** Auto completion

Auto completion for things installed with Homebrew:

#+begin_src sh
if [ -d /usr/local/etc/bash_completion.d ]; then
    for f in /usr/local/etc/bash_completion.d/*; do
        . "${f}"
    done
fi
if [ -d /opt/homebrew/etc/bash_completion.d ]; then
    for f in /opt/homebrew/etc/bash_completion.d/*; do
        . "${f}"
    done
fi
#+end_src

Tab auto completion for =pass=:

#+begin_src sh
if [ -f /usr/local/etc/bash_completion.d/pass ]; then
    source /usr/local/etc/bash_completion.d/pass
fi
# personal completion
_ppass(){
    PASSWORD_STORE_DIR=~/.password-store/personal/ _pass
}

complete -o filenames -o nospace -F _ppass ppass

_pp(){
    _ppass
}

complete -o filenames -o nospace -F _pp pp

# lingbib completion
_lb-pass(){
    PASSWORD_STORE_DIR=~/.password-store/shared-projects/lingbib/ _pass
}

complete -o filenames -o nospace -F _lb-pass lb-pass
#+end_src

Auto completion for =kubectl= and alias.

#+begin_src sh
if command -v pyenv 1>/dev/null 2>&1; then
    # Only needed if autcompletion isn't already in Hombrew bash completion dir
    #source <(kubectl completion bash)
    complete -o default -F __start_kubectl k
fi
#+end_src

***** Prompt

Let's use [[https://starship.rs/][Starship]] for our prompt, mostly just with the default configuration.

#+begin_src sh
eval "$(starship init bash)"
#+end_src

***** Colors

See [[https://apple.stackexchange.com/q/33677/85567][How can I configure Mac Terminal to have color ls output?]]

#+begin_src sh
export CLICOLOR=1
export LSCOLORS=gxBxhxDxfxhxhxhxhxcxcx
#+end_src

***** Direnv

#+begin_src sh
eval "$(direnv hook bash)"
#+end_src

***** Some Python stuff

Note that ~eval "$(pyenv virtualenv-init -)"~ needs to come after
setting ~PROMPT_COMMAND~ in order to work correctly.

#+begin_src sh
if command -v pyenv 1>/dev/null 2>&1; then
    eval "$(pyenv init -)"
fi

if command -v pyenv-virtualenv-init 1>/dev/null 2>&1; then
    eval "$(pyenv virtualenv-init -)"
fi

gpip2(){
    PIP_REQUIRE_VIRTUALENV="" pip2 "$@"
}

gpip3(){
    PIP_REQUIRE_VIRTUALENV="" pip3 "$@"
}

gpip(){
    PIP_REQUIRE_VIRTUALENV="" pip "$@"
}
#+end_src

Finally, =~/.bashrc= can be symlinked into the appropriate location,
after it is tangled:

#+begin_src sh :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
ln -sf "${HOME}/conf/bash/bashrc" "${HOME}/.bashrc"
#+end_src

***** Some Ruby stuff

#+begin_src sh
if command -v rbenv 1>/dev/null 2>&1; then
    eval "$(rbenv init -)"
fi
#+end_src

***** Symlinking into place

Finally, =~/.bashrc= can be symlinked into the appropriate location,
after it is tangled:

#+begin_src sh :eval no :exports code :tangle symlink.sh :shebang "#!/usr/bin/env bash" :padline no
ln -sf "${HOME}/conf/bash/bashrc" "${HOME}/.bashrc"
#+end_src

**** =~/.profile=
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle ~/conf/bash/profile :mkdirp yes :padline no
:END:

=~/.profile= is where stuff that is not bash-specifc goes, such as
environment variables.

#+begin_src sh
# -*- mode: sh; fill-column: 72; coding: utf-8 -*-
if [[ $OSTYPE == darwin* ]] && [[ $(uname -m) == arm64 ]]; then
    eval $(/opt/homebrew/bin/brew shellenv)
fi
if [[ ":${PATH}:" != *":${HOME}/bin:"* ]] && [ -d "${HOME}/bin" ]; then
    export PATH="${HOME}/bin:${PATH}"
fi
if [[ ":${PATH}:" != *":${HOME}/.emacs.d/bin:"* ]] && [ -d "${HOME}/.emacs.d/bin" ]; then
    export PATH="${HOME}/.emacs.d/bin:${PATH}"
fi

# ----------------------------------------------------------------------
# EDITOR
# ----------------------------------------------------------------------
if [ -f "${HOME}/bin/ec" ]; then
    export EDITOR=ec
else
    if [ -f /usr/local/bin/emacs ]; then
        export EDITOR=/usr/local/bin/emacs
    elif [ -f /opt/homebrew/bin/emacs ]; then
         export EDITOR=/opt/homebrew/bin/emacs
    else
        export EDITOR=emacs
    fi
fi
export ALTERNATE_EDITOR=""

# ----------------------------------------------------------------------
# Node stuff
# ----------------------------------------------------------------------
if command -v npm 1>/dev/null 2>&1; then
    export NODE_PATH=$(npm root -g)
fi

# ----------------------------------------------------------------------
# Python stuff
# ----------------------------------------------------------------------
if [ -d "$HOME/.pyenv" ]; then
    export PYENV_ROOT="$HOME/.pyenv"
    export PATH="$PYENV_ROOT/bin:$PATH"
    if command -v pyenv 1>/dev/null 2>&1; then
        eval "$(pyenv init --path)"
        export PYENV_VIRTUALENV_VERBOSE_ACTIVATE=1
    fi
fi
export VIRTUAL_ENV_DISABLE_PROMPT=1

# ----------------------------------------------------------------------
# Rust stuff
# ----------------------------------------------------------------------
if [ -f "${HOME}/.cargo/env" ]; then
    source "${HOME}/.cargo/env"
fi
#+end_src

Finally, =~/.profile= can be symlinked into the appropriate location,
after it is tangled:

#+begin_src sh :eval no :exports code :tangle symlink.sh :shebang "#!/usr/bin/env bash" :padline no
ln -sf "${HOME}/conf/bash/profile" "${HOME}/.profile"
#+end_src

** cmake

CMake is needed in order to compile =vterm= for use inside Emacs.

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install cmake
#+end_src

** coreutils

*** Installation

=coreutils= is already installed in the bootstrapping process as an
optional dependency for Doom Emacs.

** direnv

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install direnv
#+end_src

*** Configuration

** dvc

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install dvc
#+end_src

** editorconfig

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install editorconfig
#+end_src

** fd

*** Installation

=fd= is already installed in the bootstrapping process as an optional
dependency for Doom Emacs.

** git

*** Installation

=git= is already installed in the bootstrapping process as a dependency
for Doom Emacs.

*** Configuration

**** =~/.gitconfig=
:PROPERTIES:
:header-args:gitconfig: :eval no :exports code :tangle "~/conf/git/gitconfig" :mkdirp yes :padline no
:END:

***** =[init]=

#+begin_src gitconfig
# -*- mode: gitconfig; coding: utf-8 -*-
[init]
    defaultBranch = main
#+end_src

***** =[user]=

=git= needs to know who I am.

#+begin_src gitconfig
[user]
    name = Adam Liter
    email = io@adamliter.org
    signkey = 0x98723A2089026CD6
#+end_src

***** =[core]=

Set up my editor for =git= and a global ignore file.

#+begin_src gitconfig
[core]
    editor = "TERM=xterm-emacs emacsclient -t -a=''"
    excludesfile = ~/.gitignore_global
    attributesfile = ~/.gitattributes_global
    pager = delta
#+end_src

***** =[interactive]=

#+begin_src gitconfig
[interactive]
    diffFilter = delta --color-only
#+end_src

***** =[delta]=

#+begin_src gitconfig
[delta]
    navigate = true
    light = true
    features = line-numbers
    side-by-side = false
[delta "magit-delta"]
    line-numbers = false
#+end_src

***** =[merge]=

#+begin_src gitconfig
[merge]
    conflictstyle = diff3
#+end_src

***** =[color]=

This sets up some defaults for displaying color with =git=.

#+begin_src gitconfig
[color]
    diff = auto
    status = auto
    branch = auto
    interactive = auto
    ui = true
    pager = true
#+end_src

***** =[alias]=

This sets up an alias for automatically pushing submodules.

#+begin_src gitconfig
[alias]
    pushall = push --recurse-submodule=on-demand
#+end_src

***** =[diff]=

The following sets up a =diff= driver called =pandoc= for diffing Word
documents that =git= is tracking. For reference, see /e.g./,
[[http://blog.martinfenner.org/2014/08/25/using-microsoft-word-with-git/][Using Microsoft Word with git]].

#+begin_src gitconfig
[diff]
    colorMoved = default
[diff "pandoc"]
    textconv=pandoc --to=markdown
    prompt = false
#+end_src

***** =[filter]=

The following sets up a =filter= driver called =lfs= for using [[https://git-lfs.github.com/][Git LFS]].

#+begin_src gitconfig
[filter "lfs"]
    clean = git-lfs clean -- %f
    smudge = git-lfs smudge -- %f
    process = git-lfs filter-process
    required = true
#+end_src

***** =[push]=

The following sets the default behavior of ~git push~ such that it only
pushes the current branch to the remote repo. For further discussion,
see either of the following questions on Stack Overflow:

- [[https://stackoverflow.com/q/23918062/2571049]["simple" vs "current" push.default in git for decentralized workflow]]
- [[https://stackoverflow.com/q/13148066/2571049][Warning: push.default is unset; its implicit value is changing in Git 2.0]]

#+begin_src gitconfig
[push]
    default = simple
#+end_src

***** =[pull]=

~git pull~ should rebase by default. In versions of =git= older than
1.8.5, this can be achieved by setting the configuration option
=pull.rebase= to =true=. In =git= 1.8.5 and more recent versions, it
became possible to set the configuration option =pull.rebase= to
=preserve= (see [[https://github.com/git/git/blob/a194eaddca201163aa756faccd519f056bd3c35e/Documentation/RelNotes/1.8.5.txt#L66-L68][here]]). This is better because it runs ~git pull
--preserve-merges~ instead of ~git pull --rebase~. The use case for this
is that if you are working locally and do a non-fast-forward merge of
your feature branch into the master branch but then need to pull in
changes from the upstream master branch before being able to push, the
~git pull --rebase~ would flatten the non-fast-forward merge that you
just did, whereas ~git pull --preserve-merges~ will preserve that merge
commit.

However, in =git= 2.22.0, the option of setting [[https://github.com/git/git/blob/master/Documentation/RelNotes/2.22.0.txt#L46][=pull.rebase= to
=preserve= was deprecated]] in favor of setting =pull.rebase= to
=merges= in order to preserve merge commits. This runs ~git rebase
--rebase-merges~ behind the scenes.


#+begin_src gitconfig
[pull]
    rebase = merges
#+end_src

***** =[gpg]=

For =gpg= stuff with =git=, we want to use =gpg2=, which is now just
=gpg=, at least if installed with Homebrew.

#+begin_src gitconfig
[gpg]
    program = gpg
#+end_src

***** Configuration for [[https://github.com/magit/forge][=forge=]]

This sets up my user names on the git forges, GitHub and GitLab, for use
with [[https://github.com/magit/forge][=forge=]].

#+begin_src gitconfig
[gitlab]
    user = adamliter
[github]
    user = adamliter
#+end_src

***** Symlink into place

Finally, the =gitconfig= file needs to be symlinked into the proper
location.

#+begin_src sh :eval no :exports code :tangle symlink.sh :shebang "#!/usr/bin/env bash" :padline no
ln -sf "${HOME}/conf/git/gitconfig" "${HOME}/.gitconfig"
#+end_src

**** =~/.gitignore_global=
:PROPERTIES:
:header-args:gitignore: :eval no :exports code :tangle ~/conf/git/gitignore_global :mkdirp yes :padline no
:END:

A good reference for all sorts of patterns that =git= ought to ignore is
[[https://github.com/github/gitignore][=github/gitingore=]].

The following things are things that I have =git= ignore by default
globally.

***** macOS

Some stuff to ignore on macOS, taken from [[gh-gitignore-mac][=github/gitignore=]]. However, I
haven't added the Icon ignore pattern because [[https://superuser.com/a/298798/756208][it needs to end with a
carriage return]], and I have Emacs set up to trim trailing white
space. I'd rather not disable that for this document just to be able to
add this ignore pattern, since it is a pretty uncommon pattern and
largely only occurs in the top-level directories of the folders
associated with services like Dropbox or Google Drive (I don't generally
change/set a directory's icon).

#+begin_src gitignore
# -*- mode: gitignore; coding: utf-8 -*-
,*.DS_Store
.AppleDouble
.LSOverride

# Thumbnails
._*

# Files that might appear in the root of a volume
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent

# Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk
#+end_src

***** Linux

The following is stuff to ignore on Linux, taken from
[[gh-gitignore-linux][=github/gitignore=]].

#+begin_src gitignore
# temporary files which can be created if a
# process still has a handle open of a deleted file
.fuse_hidden*

# KDE directory preferences
.directory

# Linux trash folder which might appear on any partition or disk
.Trash-*

# .nfs files are created when an open file
# is removed but is still being accessed
.nfs*
#+end_src

***** Windows

The following is stuff to ignore in Windows, taken from
[[gh-gitignore-windows][=github/gitingore=]].

#+begin_src gitignore
# Windows image file caches
Thumbs.db
ehthumbs.db

# Dump file
,*.stackdump

# Folder config file
Desktop.ini

# Recycle Bin used on file shares
$RECYCLE.BIN/

# Windows Installer files
,*.cab
,*.msi
,*.msm
,*.msp

# Windows shortcuts
,*.lnk
#+end_src

***** Emacs

The following is Emacs stuff to ignore, taken from [[gh-gitignore-emacs][=github/gitignore=]].

#+begin_src gitignore
,*~
\#*\#
/.emacs.desktop
/.emacs.desktop.lock
,*.elc
auto-save-list
tramp
.\#*

# Org-mode
.org-id-locations
,*_archive

# flymake-mode
,*_flymake.*

# eshell files
,**/eshell/history
,**/eshell/lastdir

# elpa packages
/elpa/

# reftex files
,*.rel

# AUCTeX auto folder
,**/auto/

# cask packages
.cask/
dist/

# Flycheck
flycheck_*.el

# server auth directory
/server/

# projectiles files
.projectile

# directory configuration
.dir-locals.el
#+end_src

***** TeX

The following is stuff to ignore for (La)TeX, taken from
[[gh-gitignore-tex][=github/gitignore=]].

#+begin_src gitignore
## Core latex/pdflatex auxiliary files:
,*.aux
,*.lof
,*.log
,*.lot
,*.fls
,*.out
,*.toc
,*.fmt
,*.fot
,*.cb
,*.cb2

## Intermediate documents:
,*.dvi
,*-converted-to.*
# these rules might exclude image files for figures etc.
# *.ps
# *.eps
# *.pdf

## Generated if empty string is given at "Please type another file name for output:"
.pdf

## Bibliography auxiliary files (bibtex/biblatex/biber):
,*.bbl
,*.bcf
,*.blg
,*-blx.aux
,*-blx.bib
,*.brf
,*.run.xml

## Build tool auxiliary files:
,*.fdb_latexmk
,*.synctex
,*.synctex(busy)
,*.synctex.gz
,*.synctex.gz(busy)
,*.pdfsync

## Auxiliary and intermediate files from other packages:
# algorithms
,*.alg
,*.loa

# achemso
acs-*.bib

# amsthm
,*.thm

# beamer
,*.nav
,*.snm
,*.vrb

# changes
,*.soc

# cprotect
,*.cpt

# elsarticle
,*.spl

# endnotes
,*.ent

# fixme
,*.lox

# feynmf/feynmp
,*.mf
,*.mp
,*.t[1-9]
,*.t[1-9][0-9]
,*.tfm

#(r)(e)ledmac/(r)(e)ledpar
,*.end
,*.?end
,*.[1-9]
,*.[1-9][0-9]
,*.[1-9][0-9][0-9]
,*.[1-9]R
,*.[1-9][0-9]R
,*.[1-9][0-9][0-9]R
,*.eledsec[1-9]
,*.eledsec[1-9]R
,*.eledsec[1-9][0-9]
,*.eledsec[1-9][0-9]R
,*.eledsec[1-9][0-9][0-9]
,*.eledsec[1-9][0-9][0-9]R

# glossaries
,*.acn
,*.acr
,*.glg
,*.glo
,*.gls
,*.glsdefs

# gnuplottex
,*-gnuplottex-*

# gregoriotex
,*.gaux
,*.gtex

# hyperref
,*.brf

# knitr
,*-concordance.tex
# TODO Comment the next line if you want to keep your tikz graphics files
,*.tikz
,*-tikzDictionary

# listings
,*.lol

# makeidx
,*.idx
,*.ilg
,*.ind
,*.ist

# minitoc
,*.maf
,*.mlf
,*.mlt
,*.mtc[0-9]*
,*.slf[0-9]*
,*.slt[0-9]*
,*.stc[0-9]*

# minted
_minted*
,*.pyg

# morewrites
,*.mw

# nomencl
,*.nlo

# pax
,*.pax

# pdfpcnotes
,*.pdfpc

# sagetex
,*.sagetex.sage
,*.sagetex.py
,*.sagetex.scmd

# scrwfile
,*.wrt

# sympy
,*.sout
,*.sympy
sympy-plots-for-*.tex/

# pdfcomment
,*.upa
,*.upb

# pythontex
,*.pytxcode
pythontex-files-*/

# thmtools
,*.loe

# TikZ & PGF
,*.dpth
,*.md5
,*.auxlock

# todonotes
,*.tdo

# easy-todo
,*.lod

# xindy
,*.xdy

# xypic precompiled matrices
,*.xyc

# endfloat
,*.ttt
,*.fff

# Latexian
TSWLatexianTemp*

## Editors:
# WinEdt
,*.bak
,*.sav

# Texpad
.texpadtmp

# Kile
,*.backup

# KBibTeX
,*~[0-9]*

# auto folder when using emacs and auctex
/auto/*
#+end_src

***** Python

The following is stuff to ignore for Python, taken from
[[gh-gitignore-python][=github/gitignore=]].

#+begin_src gitignore
# Byte-compiled / optimized / DLL files
__pycache__/
,*.py[cod]
,*$py.class

# C extensions
,*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
,*.egg-info/
.installed.cfg
,*.egg

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
,*.manifest
,*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
,*.cover
.hypothesis/

# Translations
,*.mo
,*.pot

# Django stuff:
,*.log
local_settings.py

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints

# pyenv
.python-version

# celery beat schedule file
celerybeat-schedule

# SageMath parsed files
,*.sage.py

# virtualenv
.env
.venv/
venv/
ENV/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
#+end_src

***** R

The following is stuff to ignore for R, taken from [[gh-gitignore-r][=github/gitignore=]].

#+begin_src gitignore
# History files
.Rhistory
.Rapp.history

# Session Data files
.RData

# Example code in package build process
,*-Ex.R

# Output files from R CMD build
/*.tar.gz

# Output files from R CMD check
/*.Rcheck/

# RStudio files
.Rproj.user/

# produced vignettes
vignettes/*.html
vignettes/*.pdf

# OAuth2 token, see https://github.com/hadley/httr/releases/tag/v0.3
.httr-oauth

# knitr and R markdown default cache directories
/*_cache/
/cache/

# Temporary files created by R markdown
,*.utf8.md
,*.knit.md
#+end_src

***** Symlink into place

Finally, the =gitignore_global= file needs to be symlinked into the
proper location.

#+begin_src sh :eval no :exports code :tangle symlink.sh :shebang "#!/usr/bin/env bash" :padline no
ln -sf "${HOME}/conf/git/gitignore_global" "${HOME}/.gitignore_global"
#+end_src

**** =~/.gitattributes_global=
:PROPERTIES:
:header-args:gitattributes: :eval no :exports code :tangle ~/conf/git/gitattributes_global :mkdirp yes :padline no
:END:

This sets attribtues globally for Word documents so that I can diff Word
documents using the =pandoc= driver. See the [[git-config-diff][=diff= section above]].

#+begin_src gitattributes
# -*- mode: gitattributes; coding: utf-8 -*-
,*.docx diff=pandoc
,*.doc  diff=pandoc
#+end_src

Finally, the =gitattributes_global= file needs to be symlinked into the
proper location.

#+begin_src sh :eval no :exports code :tangle symlink.sh :shebang "#!/usr/bin/env bash" :padline no
ln -sf "${HOME}/conf/git/gitattributes_global" "${HOME}/.gitattributes_global"
#+end_src

** git-delta

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install git-delta
#+end_src


*** Configuration

The main behavior is configured in =~/.gitconfig= above. See [[https://dandavison.github.io/delta/usage.html][the manual]]
for configuration options and information.

** git-lfs

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install git-lfs
#+end_src

** glow

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install glow
#+end_src

** gpg

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install gnupg
#+end_src

*** Configuration

Some useful resources:

- [[https://www.void.gr/kargig/blog/2013/12/02/creating-a-new-gpg-key-with-subkeys/][Creating a new GPG key with subkeys]]
- [[https://alexcabal.com/creating-the-perfect-gpg-keypair][Creating the Perfect GPG Keypair]]
- [[https://davesteele.github.io/gpg/2014/09/20/anatomy-of-a-gpg-key/][Anatomy of a GPG Key]]

# TODO: set up gpg configuration, including pinentry-program /usr/local/bin/pinentry-mac

** helm

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install helm
#+end_src

** htop

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install htop
#+end_src

*** Configuration
:PROPERTIES:
:header-args:conf-unix: :eval no :exports code :tangle "~/conf/htop/htoprc" :mkdirp yes :padline no
:END:

Nothing for now.

#+begin_src conf-unix
# -*- mode: conf-unix; coding: utf-8; -*-
#+end_src

Symlink it into place:

#+begin_src sh :eval no :exports code :tangle symlink.sh :shebang "#!/usr/bin/env bash" :padline no
mkdir -p ~/.config/htop
ln -sf "${HOME}/conf/htop/htoprc" "${HOME}/.config/htop/htoprc"
#+end_src

** hub

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install hub
#+end_src

*** Configuration

** jq

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install jq
#+end_src

** kubernetes-cli

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install kubernetes-cli
#+end_src

** lab

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install lab
#+end_src

*** Configuration
:PROPERTIES:
:header-args:conf-toml: :eval no :exports code :tangle "~/conf/lab/lab.toml" :mkdirp yes :padline no
:END:

#+begin_src conf-toml
# -*- mode: conf-toml; coding: utf-8; -*-
[core]
  host = "https://gitlab.com"
  load_token = # TODO: set up load_token with pass
  user = "adam.liter"
#+end_src

Symlink it into place:

#+begin_src sh :eval no :exports code :tangle symlink.sh :shebang "#!/usr/bin/env bash" :padline no
mkdir -p ~/.config/lab
ln -sf "${HOME}/conf/lab/lab.toml" "${HOME}/.config/lab/lab.toml"
#+end_src

** minikube

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install minikube
#+end_src

** pandoc

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install pandoc
#+end_src

*** Configuration

There is no configuration setup for =pandoc=.

** pass

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install pass
#+end_src

*** Config

No current configuration for pass.

** pinentry-mac

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install pinentry-mac
#+end_src

Let's set it up so that the password is not saved in the macOS Keychain
(and so that this option isn't even displayed).

#+begin_src sh
defaults write org.gpgtools.common UseKeychain NO
defaults write org.gpgtools.common DisableKeychain -bool yes
#+end_src

*** Configuration

To use =pinentry-mac=, the following line needs to be set in the file
=~/.gnupg/gpg-agent.conf=:

=pinentry-program $HOMEBREW_PREFIX/bin/pinentry-mac=

This is done above in the section for configuring =gpg=.

** pre-commit

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install pre-commit
#+end_src

** reattach-to-user-namespace

This allows for accessing the clipboard from inside of =tmux= sessions
on macOS. See the [[https://github.com/ChrisJohnsen/tmux-MacOSX-pasteboard][GitHub repository for more info]].

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install reattach-to-user-namespace
#+end_src

** ripgrep

*** Installation

=ripgrep= is installed in the bootstrapping process as a dependency for
Doom Emacs.

** ruff

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install ruff
#+end_src

** ssh

*** Installation

=ssh= is already installed on both macOS and Linux, by default.

*** Configuration
:PROPERTIES:
:header-args:emacs-lisp: :eval yes :exports code :results output silent
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

My SSH configuration is kept in a submodule hosted by my private =git=
server so as to keep the details of my SSH configuration private. The
following code, which is executed when this file is tangled, will create
my SSH config and then symlink it into the appropriate location.

#+NAME: ssh-config
#+begin_src emacs-lisp
(org-babel-tangle-file "~/conf/ssh/README.org")
#+end_src

#+begin_src sh
ln -sf "${HOME}/conf/ssh/config" "${HOME}/.ssh/config"
#+end_src

** starship

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install starship
#+end_src

*** Configuration
:PROPERTIES:
:header-args:conf-toml: :eval no :exports code :tangle ~/conf/starship/starship.toml :mkdirp yes :padline no
:END:

This is our configuration, taken from the [[https://starship.rs/presets/#nerd-font-symbols][Nerd Font Symbols preset]]. The
only non-default thing here is setting =truncate_to_repo= to =false=
underneath =directory=.

#+begin_src conf-toml
# -*- mode: conf-toml; coding: utf-8; -*-
[aws]
symbol = "  "

[buf]
symbol = " "

[c]
symbol = " "

[cmake]
symbol = " "

[conda]
symbol = " "

[crystal]
symbol = " "

[dart]
symbol = " "

[directory]
read_only = " 󰌾"
truncate_to_repo = false

[docker_context]
symbol = " "

[elixir]
symbol = " "

[elm]
symbol = " "

[fennel]
symbol = " "

[fossil_branch]
symbol = " "

[git_branch]
symbol = " "

[git_commit]
tag_symbol = '  '

[golang]
symbol = " "

[guix_shell]
symbol = " "

[haskell]
symbol = " "

[haxe]
symbol = " "

[hg_branch]
symbol = " "

[hostname]
ssh_symbol = " "

[java]
symbol = " "

[julia]
symbol = " "

[kotlin]
symbol = " "

[lua]
symbol = " "

[memory_usage]
symbol = "󰍛 "

[meson]
symbol = "󰔷 "

[nim]
symbol = "󰆥 "

[nix_shell]
symbol = " "

[nodejs]
symbol = " "

[ocaml]
symbol = " "

[os.symbols]
Alpaquita = " "
Alpine = " "
AlmaLinux = " "
Amazon = " "
Android = " "
Arch = " "
Artix = " "
CachyOS = " "
CentOS = " "
Debian = " "
DragonFly = " "
Emscripten = " "
EndeavourOS = " "
Fedora = " "
FreeBSD = " "
Garuda = "󰛓 "
Gentoo = " "
HardenedBSD = "󰞌 "
Illumos = "󰈸 "
Kali = " "
Linux = " "
Mabox = " "
Macos = " "
Manjaro = " "
Mariner = " "
MidnightBSD = " "
Mint = " "
NetBSD = " "
NixOS = " "
Nobara = " "
OpenBSD = "󰈺 "
openSUSE = " "
OracleLinux = "󰌷 "
Pop = " "
Raspbian = " "
Redhat = " "
RedHatEnterprise = " "
RockyLinux = " "
Redox = "󰀘 "
Solus = "󰠳 "
SUSE = " "
Ubuntu = " "
Unknown = " "
Void = " "
Windows = "󰍲 "

[package]
symbol = "󰏗 "

[perl]
symbol = " "

[php]
symbol = " "

[pijul_channel]
symbol = " "

[python]
symbol = " "

[rlang]
symbol = "󰟔 "

[ruby]
symbol = " "

[rust]
symbol = "󱘗 "

[scala]
symbol = " "

[swift]
symbol = " "

[zig]
symbol = " "

[gradle]
symbol = " "
#+end_src

And this symlinks the configuration file into the appropriate location.

#+begin_src sh :eval no :exports code :tangle symlink.sh :shebang "#!/usr/bin/env bash" :padline no
ln -sf "${HOME}/conf/starship/starship.toml" "${HOME}/.config/starship.toml"
#+end_src

** tmux

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

Install =tmux=:

#+begin_src sh
brew install tmux
#+end_src

*** Configuration
:PROPERTIES:
:header-args:conf-unix: :eval no :exports code :tangle ~/conf/tmux/tmux.conf :mkdirp yes :padline no
:END:

To ensure that colors work properly, I've followed the suggestion in
[[https://stackoverflow.com/a/22481496/2571049][this answer]] on Stack Overflow.

#+begin_src conf-unix
# -*- coding: utf-8; mode: conf-unix; fill-column: 72 -*-
set-option -g default-terminal "xterm-256color"
#+end_src

The following ensures that the macOS pasteboard is available in =tmux=
sessions. See [[tmux-macos-pasteboard][the Github repository]] for more information.

#+begin_src conf-unix :tangle (when (eq system-type 'darwin) "~/conf/tmux/tmux.conf")
set-option -g default-command "reattach-to-user-namespace -l $SHELL"
#+end_src

The following allows the =tmux= configuration file to be reloaded.

#+begin_src conf-unix
bind-key r source-file ~/.tmux.conf
#+end_src

The following are some key bindings for opening new SSH sessions in
either a new windows, a vertically split window, or a horizontally split
window.

#+begin_src conf-unix
bind-key S   command-prompt -p "host" "new-window -n %1 'ssh %1'"
bind-key C-S command-prompt -p "host" "split-window -v 'ssh %1'"
bind-key M-S command-prompt -p "host" "split-window -h 'ssh %1'"
#+end_src

The following are some key bindings for opening Emacs in either a new
window, a vertically split window, or a horizontally split window.

#+begin_src conf-unix
bind-key y   new-window -n "emacs"  "TERM=xterm-emacs emacsclient -nw"
bind-key C-y split-window -v "TERM=xterm-emacs emacsclient -nw"
bind-key M-y split-window -h "TERM=xterm-emacs emacsclient -nw"
#+end_src

The following defines some more intuitive key bindings for splitting a
window and undefines the default key bindings for this.

#+begin_src conf-unix
bind-key | split-window -h
bind-key - split-window -v
unbind '"'
unbind %
#+end_src

The following allows for switching between =tmux= panes using just
M-<arrow>, without the =tmux= prefix key.

#+begin_src conf-unix
bind-key -n M-Left select-pane -L
bind-key -n M-Right select-pane -R
bind-key -n M-Up select-pane -U
bind-key -n M-Down select-pane -D
#+end_src

And, finally, the following symlinks the configuration file into the
appropriate location.

#+begin_src sh :eval no :exports code :tangle symlink.sh :shebang "#!/usr/bin/env bash" :padline no
ln -sf "${HOME}/conf/tmux/tmux.conf" "${HOME}/.tmux.conf"
#+end_src

** trivy

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install trivy
#+end_src

** wget

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

=wget= is not installed by default on macOS:

#+begin_src sh
brew install wget
#+end_src

** yq

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install yq
#+end_src

* Programming languages

** NodeJS

*** node

**** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install node
#+end_src

**** Configuration
:PROPERTIES:
:header-args:conf-unix: :eval no :exports code :tangle ~/conf/npm/npmrc :mkdirp yes :padline no
:END:

Nothing for now.

#+begin_src conf-unix
# -*- mode: conf-unix; coding: utf-8; -*-
#+end_src

Symlink it into place:

#+begin_src sh :eval no :exports code :tangle symlink.sh :shebang "#!/usr/bin/env bash" :padline no
ln -sf "${HOME}/conf/npm/npmrc" "${HOME}/.npmrc"
#+end_src

*** nodenv

**** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install nodenv
#+end_src

*** node packages
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

I use [[https://github.com/microsoft/pyright][pyright]] as an LSP server for Python development in Emacs.

#+begin_src sh
echo "Installing node package pyright globally ..."
npm install -g pyright
#+end_src

I also use =@commitlint/cli= and =@commitlint/config-conventional= for
commit linting across a variety of projects.

#+begin_src sh
echo "Installing @commitlint/{cli,config-conventional} globally ..."
npm install -g @commitlint/{cli,config-conventional}
#+end_src

** org
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

My default directory for =org= files is a submodule of this repository
and thus needs to be symlinked into the location of ~org-directory~,
whose value I've set to =~/org= in =.doom.d/config.el=.

#+begin_src sh
rm -rf "${HOME}/org"
ln -sn "${HOME}/conf/org" "${HOME}/org"
#+end_src

** Python

*** conda

**** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

# TODO: figure out bootstrapping conda installation

**** Configuration
:PROPERTIES:
:header-args:yaml: :eval no :exports code :tangle ~/conf/conda/condarc :mkdirp yes :padline no
:END:

[[https://stackoverflow.com/a/58045893][This answer]] to [[https://stackoverflow.com/q/58044214][Installing anaconda with pyenv, unable to configure
  virtual environment]] is helpful for installing conda alongside pyenv.

#+begin_src yaml
# -*- mode: yaml; coding: utf-8; -*-
auto_activate_base: false
channels:
  - defaults
#+end_src

Symlink the configuration file into the appropriate location:

#+begin_src sh :eval no :exports code :tangle symlink.sh :shebang "#!/usr/bin/env bash" :padline no
ln -sf "${HOME}/conf/conda/condarc" "${HOME}/.condarc"
#+end_src

*** pdm
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

**** Installation

#+begin_src sh
brew install pdm
#+end_src

*** pyenv
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

**** Installation

#+begin_src sh
brew install pyenv pyenv-virtualenv
pyenv install 3:latest
#+end_src

**** Configuration

Nothing at the moment.

** Rust

*** Installation
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install rustup
# Make sure rust-analyzer is installed for LSP
rustup component add rust-analyzer
#+end_src

***  Configuration

Nothing at the moment.

** R

# TODO: figure out bootstrapping R installation

** Ruby

# TODO: figure out bootstrapping Ruby installation

** TeX

# TODO: figure out bootstrapping TeX installation

* =${HOME}/bin=

#+begin_src sh :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
if [ -d "${HOME}/bin" ]; then
    echo "~/bin already exists; backing it up to ~/bin.bkp ..."
    cp -r "${HOME}/bin" "${HOME}/bin.bkp"
fi
rm -rf ${HOME}/bin
ln -sn "${HOME}/conf/bin" "${HOME}/bin"
#+end_src

# TODO: migrate stuff from https://github.com/adamliter/bin

** =ec=
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle ~/conf/bin/ec :mkdirp yes :shebang "#!/bin/sh" :padline no
:END:

#+begin_src sh
TERM=xterm-emacs emacsclient -t -a="" "$@"
#+end_src

* Applications and GUIs

# TODO: flesh out this section, and figure out Alfred and iterm2 configs

** Alfred

** Amphetamine

** Bartender

** Cardhop

** Contexts

** Discord

** Dropbox

** Fantastical

** Final Cut Pro

** Firefox

** Flux

** Google Chrome

** Google Drive

** Handbrake

** Inkscape

** iTerm2

** LibreOffice

** Maestral

** Magnet

** MailMate

** MakeMKV

** ownCloud

** Peek

** Plex

** Praat

** PsychoPy

** RStudio

** Signal

** Skim

** Slack

** Spotify

** Sublime Text

** Tor

** Transmission

** UnicodeChecker

** VLC

** Xcode

** Zoom

* Fonts

** Monaspace
:PROPERTIES:
:header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
:END:

#+begin_src sh
brew install --cask font-monaspace
#+end_src
