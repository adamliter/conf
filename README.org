#+TITLE: Adam Liter's computer configuration
#+AUTHOR: Adam Liter
#+EMAIL: io@adamliter.org

#+LANGUAGE: en

This =org= file documents how to bootstrap the setup of a new machine
such that it is configured just like all of my other computers/servers.

#+TOC: headlines 1

* New machine setup

** SSH
   :PROPERTIES:
   :header-args:sh: :eval no
   :END:

The first thing that must be done in order to set up a new machine is to
configure SSH and create a key. This allows for cloning of [[https://github.com/adamliter/config-files][the =git=
repo that contains my configuration files]], which is hosted on GitHub.

First, create the SSH directory:

#+BEGIN_SRC sh
  mkdir -p ~/.ssh
  chmod 700 ~/.ssh
#+END_SRC

Optionally, I can also set up an =authorized_keys= file, which is useful
if the new machine is intended to be used as a server in any capacity.

#+BEGIN_SRC sh
  touch ~/.ssh/authorized_keys
  chmod 600 ~/.ssh/authorized_keys
#+END_SRC

Next, I need to actually create a new SSH key, which can be done with:

#+BEGIN_SRC sh
  ssh-keygen -t rsa -b 4096 -C "COMMENT GOES HERE"
#+END_SRC

Then, I can set up a basic SSH configuration file to ensure that the key
that I just generated is used when trying to connect to GitHub as well
as my private =git= server, which contains some of the submodules in
this repository. (Note that this basic SSH configuration file will be
overwritten later in this new machine configuration process.)

This allows repositories to be cloned in either of the following manners:

1. ~git clone ssh://github/adamliter/config-files.git~
2. ~git clone github:adamliter/config-files.git~

#+BEGIN_SRC sh
  cat > ~/.ssh/config <<EOF
  Host github
    Hostname github.com
    IdentityFile ~/.ssh/id_rsa
    User git

  Host algit
    Hostname git.adamliter.org
    IdentityFile ~/.ssh/id_rsa
    User git

  # Local Variables:
  # mode: conf
  # coding: utf-8
  # fill-column: 72
  # indent-tabs-mode: nil
  # End:
  EOF
  chmod 600 ~/.ssh/config
#+END_SRC

Finally, the public key needs to be added to GitHub and to
~/home/git/.ssh/authorized_keys~ on the machine ~git.adamliter.org~.

** Bootstrapping
   :PROPERTIES:
   :header-args:sh: :eval no
   :END:

To bootstrap the setup of a new machine, use the =bootstrap.sh= script,
described [[bootstrap-script-explanation][below]].

*** macOS

To bootstrap the setup of a new Mac machine, do:

#+BEGIN_SRC sh
  curl -fsSL https://raw.githubusercontent.com/adamliter/config-files/master/bootstrap.sh | bash -v
#+END_SRC

*** Linux

~curl~ is not installed on Ubuntu by default, but ~wget~ is. To
bootstrap the setup of a new Linux machine, do:

#+BEGIN_SRC sh
  wget -O- https://raw.githubusercontent.com/adamliter/config-files/master/bootstrap.sh | bash -v
#+END_SRC

*** Windows

Meh ... Maybe someday ...

** <<bootstrap-script-explanation>>=bootstrap.sh=
   :PROPERTIES:
   :header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash"
   :END:

There is a [[https://raw.githubusercontent.com/adamliter/config-files/master/bootstrap.sh][bootstrap script]] for getting an up-to-date package manager,
Emacs, and =git= for both macOS and Linux (only tested on Ubuntu and
(currently) only intended for Debian-based systems because of the
assumption that =apt= is the package manager).

That script is written to this repository when this file is tangled. The
output of the tangling is not ignored by version control even though it
is a derived file because tracking it allows a ~curl~-able version of
the file to exist on GitHub for bootstrapping the setup of a new
machine.

The first thing the script does is set some flags for exiting and
debugging:

#+BEGIN_SRC sh
  # -*- coding: utf-8; mode: sh; -*-
  # Exit when a command fails
  set -o errexit
  # Exit when a command in a series of pipes fails
  set -o pipefail
  # Exit when there is an undeclared variable
  set -o nounset
  # Trace what gets executed (for debugging)
  #set -o xtrace
#+END_SRC

Next, the script detects the operating system.

#+BEGIN_SRC sh
  if [[ $OSTYPE == darwin* ]]; then
      BASH_OS_TYPE='macOS'
  elif [[ $OSTYPE == linux-gnu ]]; then
      BASH_OS_TYPE='Linux'
  elif [[ '$OS' == Windows* ]]; then
      BASH_OS_TYPE='Windows'
  else
      BASH_OS_TYPE='Unknown'
  fi
#+END_SRC

Then, based on the OS, it installs and/or updates the package manager.
Using the package manager, it also installs both Emacs and =git=, which
will allow for programatically setting up the rest of my configuration.

#+BEGIN_SRC sh
  if [[ $BASH_OS_TYPE == macOS ]]; then
      if type brew >/dev/null 2>&1; then
          echo "Homebrew is already installed ..."
      else
          /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
      fi
      brew update && brew upgrade
      brew tap caskroom/cask
      brew cask install emacs
      brew install git
  elif [[ $BASH_OS_TYPE == Linux ]]; then
      sudo apt-get update -y && sudo apt-get upgrade -y
      sudo apt-get install -y emacs
      sudo apt-get install -y git
  fi
#+END_SRC

Next, the script clones [[https://github.com/adamliter/config-files][the repository that contains my configuration
files]] into =${HOME}/config-files=. If that file already exists, the
~git clone~ command will fail, so I remove it first just to be cautious,
but this should be unnecessary if this is a new machine.

In the case that this is not a new machine, the command ~rm -rf
"${HOME}/config-files"~ will remove the file =~/.ssh/config=, since that
file is a symlink that points inside of the =git= repository. This will
cause the =bootstrap.sh= script to fail since the submodules in the
repository make use of the SSH hosts defined in the SSH config
file. Thus, in order to ensure that this =bootstrap.sh= script can also
be run on a machine that is already setup (to, for example, reset how
everything is configured or apply new changes), we want to ensure that
those SSH hosts still exist when this script tries to clone the repo and
its submodules.

#+BEGIN_SRC sh
  if [ -f "${HOME}/.ssh/config" ]; then
      cp -H "${HOME}/.ssh/config" "${HOME}/.ssh/config.temp"
      rm "${HOME}/.ssh/config"
      mv "${HOME}/.ssh/config.temp" "${HOME}/.ssh/config"
  fi
  rm -rf "${HOME}/config-files"
  git clone github:adamliter/config-files.git "${HOME}/config-files"
#+END_SRC

After cloning, it updates all submodules. Submodules, as always, are a
bit tricky. ~git submodule update --init --recursive~ will recursively
initialize and update all submodules in the =git= repo. Moreover, with
the ~--remote~ flag, any submodules that are specified to track a branch
on the remote will be fast-forwarded to the most recent commit on that
branch on the remote, regardless of the status of the submodule in the
parent repo. Furthermore, since [[https://stackoverflow.com/a/20797186/2571049][submodules are always checked out in a
detached HEAD state]], the script also checks out either the branch that
the submodule is set up to track on the remote or the master branch for
all submodules.

#+BEGIN_SRC sh
  cd "${HOME}/config-files"
  git submodule update --init --remote --recursive

  git submodule foreach --recursive \
    'git checkout \
    $(git config -f $toplevel/.gitmodules submodule.$name.branch || \
    echo master)'
#+END_SRC

After all the futzing around with submodules, it symlinks some things
into place.

#+BEGIN_SRC sh
  rm -rf "${HOME}/.emacs.d"
  ln -sn "${HOME}/config-files/emacs.d" "${HOME}/.emacs.d"
#+END_SRC

Next, the script evaluates my =init.el= file in order to bootstrap the
installation of all of the Emacs packages that I use. The ~--batch~
option to ~emacs~ prevents Emacs from being opened as en
editor. Instead, it just evaluates the file specified by ~--load~.

#+BEGIN_SRC sh
  emacs --batch --load="${HOME}/.emacs.d/init.el"
#+END_SRC

Finally, the script evaluates all source code blocks in the file
=${HOME}/config-files/README.org= where ~:eval yes~ as well as tangling
the file in order to put all other configuration information in the
proper locations.

#+BEGIN_SRC sh
  emacs --batch \
    --eval="(progn
    (require 'org)
    (setq org-confirm-babel-evaluate nil)
    (find-file \"~/config-files/README.org\")
    (org-babel-tangle)
    (org-babel-execute-buffer)
    (kill-buffer))"
#+END_SRC

* Command line utilities

This section of this =org= document both installs the relevant command
line utility (if it is not already installed) and creates the
appropriate configuration files for that utility, if necessary. Even
though all of the configuration files are derived files, they are all
kept under version control and symlinked into the appropriate
locations. Doing so allows me to more readily notice any external
programs or utilities that change my configuration files, as it will
lead to a dirty working tree in =git=.

** All OSes

*** bash

**** Installation
     :PROPERTIES:
     :header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash"
     :END:

The version of bash that ships on macOS is pretty outdated, so let's
install a more recent version via Homebrew. In order to use this newer
version of bash as the login shell, it needs to be added to the file
=/etc/shells=. Then, the shell can be changed to =/usr/local/bin/bash=
for the current user. In order for this to take effect, I log back in.

#+BEGIN_SRC sh
  if [[ $BASH_OS_TYPE == macOS ]]; then
      brew update && brew install bash
      if ! grep -q "/usr/local/bin/bash" /etc/shells; then
          echo "Adding Homebrew's bash to possible login shells ..."
          sudo bash -c "echo /usr/local/bin/bash >> /etc/shells"
      else
          echo "Homebrew's bash is already a possible login shell ..."
      fi
      if [ $SHELL == "/usr/local/bin/bash" ]; then
          echo "Shell is already set to Homebrew's bash ..."
      else
          echo "Setting shell to Homebrew's bash ..."
          chsh -s /usr/local/bin/bash
      fi
  fi
#+END_SRC

**** Configuration

References:

- [[https://superuser.com/q/183870/756208][Difference between .bashrc and .bash_profile]]
- [[https://superuser.com/q/789448/756208][Choosing between .bashrc, .profile, .bash_profile, etc]]

***** =~/.bash_profile=
      :PROPERTIES:
      :header-args:sh: :eval no :exports code :tangle ~/config-files/bash/bash_profile :mkdirp yes :padline no
      :END:

Login shells (/e.g./ a shell that you start from a non-graphical desktop
environment, like when logging into a machine via SSH) read one of three
files (assuming your shell is bash):

1. =~/.bash_profile=
2. =~/.bash_login=
3. =~/.profile=

Whichever file is found first is the one that gets read, and the shell
stops looking for the others. Furthermore, login shells do *not* read
=~/.bashrc=, but the best practice is to have an *interactive* login
shell read =~/.bashrc=. Ensuring that this happens is done by adding the
following to the =~/.bash_profile= file:

#+BEGIN_SRC sh
  # -*- mode: sh; fill-column: 72; coding: utf-8 -*-
  if [ -f "${HOME}/.bashrc" ] && [[ $- == *i* ]]; then
      source "${HOME}/.bashrc"
  fi
#+END_SRC

It's worth noting that on macOS, unlike on Linux, all shells started
from Terminal.app (or iTerm.app) in a graphical environment are started
as login shells and thus read =~/.bash_profile= (instead of =~/.bashrc=,
which is what is read when starting Terminal in a graphical desktop
environment on Linux, since it is a non-login shell). Thus, if you want
anything in your =~/.bashrc= to be read when using macOS, you certainly
need to make sure that =~/.bash_profile= sources =~/.bashrc=.

At any rate, this can now be symlinked into the appropriate location,
after it is tangled:

#+BEGIN_SRC sh :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash"
  ln -sf "${HOME}/config-files/bash/bash_profile" "${HOME}/.bash_profile"
#+END_SRC

***** =~/.bashrc=
      :PROPERTIES:
      :header-args:sh: :eval no :exports code :tangle ~/config-files/bash/bashrc :mkdirp yes :padline no
      :END:

In the =~/.bashrc= file, I want to ensure that the system-wide =bashrc=
file is read, if it exists:

#+BEGIN_SRC sh
  if [ -f /etc/bashrc ]; then
      source /etc/bashrc
  fi
#+END_SRC

While it is not considered best practice to source =~/.profile= from
inside of =~/.bashrc= (in particular, see [[https://superuser.com/a/183980/756208][Gilles's answer]] to [[https://superuser.com/q/183870/756208][Difference
between .bashrc and .bash_profile]]), I'm going to go ahead and do this
anyway because it makes life easier, and I have yet to encounter any
problems because of it. The recommended best practice is to source
=~/.basrhc= and =~/.profile= from =~/.bash_profile=, in that
order. However, for the reasonos mentioned above when discussing macOS
shells started in the graphical desktop environment, most shells started
in a graphical desktop environment will only read =~/.bashrc= because
they are non-login shells. However, this means that environment
variables that are set in =~/.profile= will not be available in these
shells. So I'll flout the best practice for now, until I run into
problems because of it.

#+BEGIN_SRC sh
  if [ -f "${HOME}/.profile" ]; then
      source "${HOME}/.profile"
  fi
#+END_SRC

****** Aliases

Always gotta shrug:

#+BEGIN_SRC sh
  alias eh="echo ¯\\\_\(ツ\)_/¯ | pbcopy"
  alias ehh="eh"
#+END_SRC

Some aliases for changing directories:

#+BEGIN_SRC sh
  alias .1='cd ..'
  alias ..='cd ..'
  alias .2='cd ../..'
  alias ....='cd ../..'
  alias .3='cd ../../..'
  alias .4='cd ../../../..'
  alias .5='cd ../../../../..'
#+END_SRC

List all the things:

#+BEGIN_SRC sh
  alias l='ls -aF'
  alias ll='ls -alF'

  # list only hidden directories and files
  alias l.='ls -dF .*'
  alias ll.'=ls -ldF .*'
#+END_SRC

To ensure the availability of 256 colors in =tmux= (see [[https://stackoverflow.com/a/10163861/2571049][this answer]] to
[[https://stackoverflow.com/q/10158508/2571049][lose vim colorscheme in tmux mode]]).

#+BEGIN_SRC sh
  alias tmux='tmux -2'
#+END_SRC

Some =gpg= aliases:

#+BEGIN_SRC sh
  alias gpg='gpg2'
  alias gpgusb='gpg2 --home=/Volumes/adamliter/.gnupg'
#+END_SRC

Some macOS-specific aliases:

#+BEGIN_SRC sh
  if [[ $OSTYPE == darwin* ]]; then
      alias tw='open -a "TextWrangler"'
      alias showFiles='defaults write com.apple.finder AppleShowAllFiles \
  YES; killall Finder'
      alias hideFiles='defaults write com.apple.finder AppleShowAllFiles NO; \
  killall Finder'
  fi
#+END_SRC

Some aliases for Homebrew:

#+BEGIN_SRC sh
  if type brew >/dev/null 2>&1; then
      alias bud='brew update -v'
      alias bug='brew upgrade  -v'
      alias brc='brew cleanup -v'
      alias brp='brew prune -v'
      alias bra='bud && bug && brc && brp'
  fi
#+END_SRC

An SSH alias for =ssh-add=:

#+BEGIN_SRC sh
  alias sshid='ssh-add ~/.ssh/id_rsa'
#+END_SRC

Some aliases for =pass=:

#+BEGIN_SRC sh
  alias ppass='PASSWORD_STORE_DIR=~/.password-store/personal/ pass'
  alias pp='ppass'

  # lingbib password store
  alias lb-pass='PASSWORD_STORE_DIR=~/.password-store/shared-projects\
  /lingbib/ pass'

  # common logins
  alias amazon='pp -c misc/amazon'
  alias amex='pp -c finances/amex'
  alias bb='pp -c misc/bitbucket'
  alias chess='pp -c misc/chess'
  alias delta='pp -c travel/delta'
  alias fmail='pp -c email/fastmail/password'
  alias kb='pp -c keybase/passphrase'
  alias msufcu='pp -c finances/msufcu'
#+END_SRC

Some aliases for Emacs:

#+BEGIN_SRC sh
  alias e='emacsclient -t -a=""'
#+END_SRC

Some aliases for =git= and =hub=:

#+BEGIN_SRC sh
  if type hub >/dev/null 2>&1; then
      alias git='hub'
  fi
  alias g='git status -sb'
  alias gp='git pull'
  alias gpr='git pull --rebase'
  alias gpp='git pull --rebase && git push'
  alias ga='git add'
  alias gc='git commit'
  alias gcn='git commit --no-edit'
  alias gce='git commit -e'
  alias gces='git commit -eS'
  alias gca='git commit --amend'
  alias gcah='git commit --amend -C HEAD'
  alias gcv='git commit --no-verify'
  alias gdv='git diff'
  alias gdc='git diff --cached'
  alias gl='git log --oneline --decorate --graph'
  alias gla='git log --oneline --decorate --graph --all'
  alias gt='git tag'
  alias grc='git rebase --continue'
  alias gsl='git stash list'
  alias gss='git stash save'
#+END_SRC

Some aliases for some common directories:

#+BEGIN_SRC sh
  if type brew >/dev/null 2>&1; then
      alias cdcbrew='cd $(brew --repository homebrew/core)'
  fi
  alias cdpsite='cd ~/projects/website-src'
  alias cdtex='cd ~/Dropbox/TeXnology'
  alias cdlingsem='cd ~/Dropbox/TeXnology/lingsem'
  alias cdconfig='cd ~/config-files'
  alias cdcv='cd ~/Dropbox/SillyCareerStuff/adamlitercv'
  alias cdresume='cd ~/Dropbox/SillyCareerStuff/adamliterresume'
  alias cdling='cd ~/Dropbox/linguistics'
  alias cdugradthesis='cd ~/Dropbox/linguistics/undergrad-thesis'
  alias cdmastersthesis='cd ~/Dropbox/linguistics/masters-thesis'
  alias cdemacs='cd ~/config-files/.emacs.d'
#+END_SRC

An alias for using CorpusSearch:

#+BEGIN_SRC sh
  if [ -f "${HOME}/Applications/CS_2.003.04.jar" ]; then
      alias CS='java -classpath ~/Applications/CS_2.003.04.jar \
  csearch/CorpusSearch'
  fi
#+END_SRC

****** Auto completion

Tab auto completion for =git= and =hub=:

#+BEGIN_SRC sh
  if [ -f /usr/local/etc/bash_completion.d/git-completion.bash ]; then
      source /usr/local/etc/bash_completion.d/git-completion.bash
  fi

  if [ -f /usr/local/etc/bash_completion.d/hub.bash_completion.sh ]; then
      source /usr/local/etc/bash_completion.d/hub.bash_completion.sh
  fi
#+END_SRC

Tab auto completon for pandoc:

#+BEGIN_SRC sh
  if [ -f /usr/local/etc/bash_completion.d/pandoc ]; then
      source /usr/local/etc/bash_completion.d/pandoc
  fi
#+END_SRC

Tab auto completion for Django:

#+BEGIN_SRC sh
  if [ -f /usr/local/etc/bash_completion.d/django ]; then
      source /usr/local/etc/bash_completion.d/django
  fi
#+END_SRC

Tab auto completion for Homebrew:

#+BEGIN_SRC sh
  if [ -f /usr/local/etc/bash_completion.d/brew ]; then
      source /usr/local/etc/bash_completion.d/brew
  fi
#+END_SRC

Tab auto completion for =tmux=:

#+BEGIN_SRC sh
  if [ -f /usr/local/etc/bash_completion.d/tmux ]; then
      source /usr/local/etc/bash_completion.d/tmux
  fi
#+END_SRC

Tab auto completion for =pass=:

#+BEGIN_SRC sh
  if [ -f /usr/local/etc/bash_completion.d/pass ]; then
      source /usr/local/etc/bash_completion.d/pass
  fi
  # personal completion
  _ppass(){
      PASSWORD_STORE_DIR=~/.password-store/personal/ _pass
  }

  complete -o filenames -o nospace -F _ppass ppass

  _pp(){
      _ppass
  }

  complete -o filenames -o nospace -F _pp pp

  # lingbib completion
  _lb-pass(){
      PASSWORD_STORE_DIR=~/.password-store/shared-projects/lingbib/ _pass
  }

  complete -o filenames -o nospace -F _lb-pass lb-pass
#+END_SRC

****** Prompt

First, let's set up some more useful ways to refer to colors:

#+BEGIN_SRC sh
  RED="\[\e[31m\]"
  LIGHT_RED="\[\e[91m\]"
  GREEN="\[\e[32m\]"
  LIGHT_GREEN="\[\e[92m\]"
  YELLOW="\[\e[33m\]"
  LIGHT_YELLOW="\[\e[93m\]"
  BLUE="\[\e[34m\]"
  LIGHT_BLUE="\[\e[94m\]"
  MAGENTA="\[\e[35m\]"
  LIGHT_MAGENTA="\[\e[95m\]"
  CYAN="\[\e[36m\]"
  LIGHT_CYAN="\[\e[96m\]"
  LIGHT_GREY="\[\e[37m\]"
  LIGHT_GRAY="\[\e[37m\]"
  WHITE="\[\e[97m\]"
  COLOR_RESET="\[\e[0m\]"
#+END_SRC

Next, let's define a separator to separate information in the prompt:

#+BEGIN_SRC sh
  MY_PS1_SEP=" ${WHITE}█${COLOR_RESET} "
#+END_SRC

Next, let's write a function to determine if the current directory is a
=git= repo:

#+BEGIN_SRC sh
  function is_git_repository {
      git branch > /dev/null 2>&1
  }
#+END_SRC

If it is, we'll want to determine some information about it:

#+BEGIN_SRC sh
  function set_git_branch {
      # Capture the output of the "git status" command.
      git_status="$(git status 2> /dev/null)"

      # Set color based on clean/staged/dirty.
      if [[ ${git_status} =~ "working tree clean" ]]; then
          state="${LIGHT_GREEN}"
      elif [[ ${git_status} =~ "Changes to be committed" ]]; then
          state="${LIGHT_YELLOW}"
      else
          state="${RED}"
      fi

      # Set arrow icon based on status against remote.
      remote_pattern="(# )?Your branch is (ahead of|behind)"
      if [[ ${git_status} =~ ${remote_pattern} ]]; then
          if [[ ${BASH_REMATCH[2]} == "ahead of" ]]; then
              remote="↑"
          else
              remote="↓"
          fi
      else
          remote=""
      fi
      diverge_pattern="(# )?Your branch and (.*) have diverged"
      if [[ ${git_status} =~ ${diverge_pattern} ]]; then
          remote="↕"
      fi

      # Get the name of the branch.
      branch_pattern="^(# )?On branch ([^${IFS}]*)"
      if [[ ${git_status} =~ ${branch_pattern} ]]; then
          branch=${BASH_REMATCH[2]}
      fi

      # Set the final branch string.
      BRANCH="${MY_PS1_SEP}${state}(${branch})${remote}${COLOR_RESET}"
  }
#+END_SRC

Additionally, if this is also a Python virtual environment, we'll want
to add some information about that to the prompt:

#+BEGIN_SRC sh
  function set_virtualenv () {
      if test -z "$VIRTUAL_ENV"; then
          MY_VENV=""
      else
          MY_VENV="${LIGHT_GREY}[${VIRTUAL_ENV##*/}]${COLOR_RESET}\
  ${MY_PS1_SEP}"
      fi
  }
#+END_SRC

We can also change the color of the prompt symbol, based on the exit
code of the last command. Here's a function to get and set that
information:

#+BEGIN_SRC sh
  function set_prompt_symbol () {
      if test $1 -eq 0 ; then
          PROMPT_SYMBOL="\$"
      else
          PROMPT_SYMBOL="${RED}\$${COLOR_RESET}"
      fi
  }
#+END_SRC

I'd also like to shorten the path to the current working directory in
the prompt if there isn't enough room to display it in the shell. In
order to do this, I need to first compute the prompt minus the working
directory in order to determine the number of remaining columns that I
have left to work with:

#+BEGIN_SRC sh
  strip_color () {
      COLOR_REGEX='s/\\\[\\e\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]\\\]//g'
      if [[ $OSTYPE == darwin* ]]; then
          sed -Ee $COLOR_REGEX <<< """$1"""
      else
          sed -re $COLOR_REGEX <<< """$1"""
      fi
  }

  get_ps1_less_pwd () {
      PS1_LESS_PWD=$(printf "%s%s%s%s" \
                            "$(strip_color "${MY_VENV}")" \
                            "$(whoami)@$(hostname -s)" \
                            "$(strip_color "${MY_PS1_SEP}")" \
                            "$(strip_color "${BRANCH}")")
  }
#+END_SRC

Now I can finally declare the function to actually compute and calculate
the bash prompt:

#+BEGIN_SRC sh
  function set_bash_prompt () {
      # Set the PROMPT_SYMBOL variable. We do this first so we don't lose the
      # return value of the last command.
      set_prompt_symbol $?

      # Get virtualenv info
      set_virtualenv

      # Set the BRANCH variable.
      if is_git_repository ; then
          set_git_branch
      else
          BRANCH=''
      fi

      # get PS1_LESS_PWD to calculate length remaining
      get_ps1_less_pwd

      # get truncated PWD
      # loosely based on http://stackoverflow.com/a/26555347/2571049
      MY_PWD=$(pwd | awk -F/ -v "u=$PS1_LESS_PWD" -v "n=$(tput cols)" \
                         -v "h=^$HOME" \
                         '{sub(h,"~"); u=length(u); n=n-u-1; b=$1} \
                         length($0)<=n || NF==2 {print; next;} \
                         NF>2 {b=b"/.../"; e=$NF; n-=length(b $NF); \
                         for (i=NF-1; i>2 && n>length(e $i)+1; i--) e=$i"/"e;} {print b e;}')

      # Set the bash prompt variable.
      PS1="
  ${MY_VENV}\
  ${WHITE}\u${COLOR_RESET}\
  ${LIGHT_GREEN}@${COLOR_RESET}\
  ${LIGHT_MAGENTA}\h${COLOR_RESET}\
  ${MY_PS1_SEP}\
  ${LIGHT_CYAN}${MY_PWD}${COLOR_RESET}\
  ${BRANCH}
  ${PROMPT_SYMBOL} "
  }
#+END_SRC

And, finally, we can actually call the function to set the prompt:

#+BEGIN_SRC sh
  PROMPT_COMMAND=set_bash_prompt
#+END_SRC

****** Colors

See [[https://apple.stackexchange.com/q/33677/85567][How can I configure Mac Terminal to have color ls output?]]

#+BEGIN_SRC sh
  export CLICOLOR=1
  export LSCOLORS=gxBxhxDxfxhxhxhxhxcxcx
#+END_SRC

****** Some Python stuff

#+BEGIN_SRC sh
  source /usr/local/bin/virtualenvwrapper.sh

  gpip2(){
      PIP_REQUIRE_VIRTUALENV="" pip2 "$@"
  }

  gpip3(){
      PIP_REQUIRE_VIRTUALENV="" pip3 "$@"
  }
#+END_SRC

Finally, =~/.bashrc= can be symlinked into the appropriate location,
after it is tangled:

#+BEGIN_SRC sh :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash"
  ln -sf "${HOME}/config-files/bash/bashrc" "${HOME}/.bashrc"
#+END_SRC

***** =~/.profile=
      :PROPERTIES:
      :header-args:sh: :eval no :exports code :tangle ~/config-files/bash/profile :mkdirp yes :padline no
      :END:

=~/.profile= is where stuff that is not bash-specifc goes, such as
environment variables.

#+BEGIN_SRC sh
  # -*- mode: sh; fill-column: 72; coding: utf-8 -*-

  if [[ ":${PATH}:" != *":${HOME}/bin:"* ]] && [ -d "${HOME}/bin" ]; then
      export PATH="${HOME}/bin:${PATH}"
  fi

  # This should come at the end of any path stuff,
  # otherwise the rvm-managed version of Ruby
  # will not be at the beginning of the path, and rvm
  # will complain about this

  [[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm" # Load RVM into a shell session *as a function*

  export PATH="$PATH:$HOME/.rvm/bin" # Add RVM to PATH for scripting

  # ----------------------------------------------------------------------
  # EDITOR
  # ----------------------------------------------------------------------
  export EDITOR=/usr/local/bin/ec
  export ALTERNATE_EDITOR=""

  # ----------------------------------------------------------------------
  # Python stuff
  # ----------------------------------------------------------------------
  export PIP_REQUIRE_VIRTUALENV=true
  export VIRTUALENVWRAPPER_PYTHON=$(which python3)
  export PROJECT_HOME=$HOME/projects
  export WORKON_HOME=$HOME/.virtualenvs
  export VIRTUAL_ENV_DISABLE_PROMPT=1

#+END_SRC

Finally, =~/.profile= can be symlinked into the appropriate location,
after it is tangled:

#+BEGIN_SRC sh :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash"
  ln -sf "${HOME}/config-files/bash/profile" "${HOME}/.profile"
#+END_SRC

*** curl

~curl~ is installed by default on macOS but not on Linux:

*** git

*** gpg

*** htop

*** hub

*** pandoc

*** password-store

*** ssh

**** Configuration
     :PROPERTIES:
     :header-args:emacs-lisp: :eval yes :exports code :results output silent
     :header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash"
     :END:

My SSH configuration is kept in a submodule hosted by my private =git=
server so as to keep the details of my SSH configuration private. The
following code, which is executed when this file is tangled, will create
my SSH config and then symlink it into the appropriate location.

#+NAME: ssh-config
#+BEGIN_SRC emacs-lisp
  (org-babel-tangle-file "~/config-files/ssh/README.org")
#+END_SRC

#+BEGIN_SRC sh
  ln -sf "${HOME}/config-files/ssh/config" "${HOME}/.ssh/config"
#+END_SRC

*** tmux

*** tree

This should be installed when =password-store= is installed.

*** wget

~wget~ is installed by default on Linux but not on macOS:

*** xclip

** macOS only

*** reattach-to-user-namespace

** Linux only

* Programming languages

** All OSes

*** Python

*** R

*** TeX

** macOS only

** Linux only

* Applications and GUIs

** All OSes

*** Dropbox

*** Firefox

*** Google Chrome

*** Google Drive

*** Handbrake

*** Inkscape

*** LibreOffice

*** MakeMKV

*** ownCloud

*** Plex

*** Praat

*** PsychoPy

*** RStudio

*** Skype

*** Spotify

*** VirtualBox

*** VLC

** macOS only

*** Alfred

*** Flux

*** iTerm2

*** MailMate

*** Skim

*** TextWrangler

*** UnicodeChecker

** Linux only

# Local Variables:
# mode: org
# coding: utf-8
# fill-column: 72
# indent-tabs-mode: nil
# End:
