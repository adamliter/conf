#+TITLE: Adam Liter's computer configuration
#+AUTHOR: Adam Liter
#+EMAIL: io@adamliter.org

#+LANGUAGE: en

This =org= file documents how to bootstrap the setup of a new machine
such that it is configured just like all of my other computers/servers.

#+TOC: headlines 1

* New machine setup

** SSH
   :PROPERTIES:
   :header-args:sh: :eval no
   :END:

The first thing that must be done in order to set up a new machine is to
configure SSH and create a key. This allows for cloning of [[https://github.com/adamliter/config-files][the =git=
repo that contains my configuration files]], which is hosted on GitHub.

First, create the SSH directory:

#+BEGIN_SRC sh
  mkdir -p ~/.ssh
  chmod 700 ~/.ssh
#+END_SRC

Optionally, I can also set up an =authorized_keys= file, which is useful
if the new machine is intended to be used as a server in any capacity.

#+BEGIN_SRC sh
  touch ~/.ssh/authorized_keys
  chmod 600 ~/.ssh/authorized_keys
#+END_SRC

Next, I need to actually create a new SSH key, which can be done with:

#+BEGIN_SRC sh
  ssh-keygen -t rsa -b 4096 -C "COMMENT GOES HERE"
#+END_SRC

Then, I can set up a basic SSH configuration file to ensure that the key
that I just generated is used when trying to connect to GitHub as well
as my private =git= server, which contains some of the submodules in
this repository. (Note that this basic SSH configuration file will be
overwritten later in this new machine configuration process.)

This allows repositories to be cloned in either of the following manners:

1. ~git clone ssh://github/adamliter/config-files.git~
2. ~git clone github:adamliter/config-files.git~

#+BEGIN_SRC sh
  cat > ~/.ssh/config <<EOF
  Host github
    Hostname github.com
    IdentityFile ~/.ssh/id_rsa
    User git

  Host algit
    Hostname git.adamliter.org
    IdentityFile ~/.ssh/id_rsa
    User git

  # Local Variables:
  # mode: conf
  # coding: utf-8
  # fill-column: 72
  # indent-tabs-mode: nil
  # End:
  EOF
  chmod 600 ~/.ssh/config
#+END_SRC

Finally, the public key needs to be added to GitHub and to
~/home/git/.ssh/authorized_keys~ on the machine ~git.adamliter.org~.

** Bootstrapping
   :PROPERTIES:
   :header-args:sh: :eval no
   :END:

To bootstrap the setup of a new machine, use the =bootstrap.sh= script,
described [[bootstrap-script-explanation][below]].

*** macOS

To bootstrap the setup of a new Mac machine, do:

#+BEGIN_SRC sh
  curl -fsSL https://raw.githubusercontent.com/adamliter/config-files/master/bootstrap.sh | bash -v
#+END_SRC

*** Linux

~curl~ is not installed on Ubuntu by default, but ~wget~ is. To
bootstrap the setup of a new Linux machine, do:

#+BEGIN_SRC sh
  wget -O- https://raw.githubusercontent.com/adamliter/config-files/master/bootstrap.sh | bash -v
#+END_SRC

*** Windows

Meh ... Maybe someday ...

** <<bootstrap-script-explanation>>=bootstrap.sh=
   :PROPERTIES:
   :header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
   :END:

There is a [[https://raw.githubusercontent.com/adamliter/config-files/master/bootstrap.sh][bootstrap script]] for getting an up-to-date package manager,
Emacs, and =git= for both macOS and Linux (only tested on Ubuntu and
(currently) only intended for Debian-based systems because of the
assumption that =apt= is the package manager).

That script is written to this repository when this file is tangled. The
output of the tangling is not ignored by version control even though it
is a derived file because tracking it allows a ~curl~-able version of
the file to exist on GitHub for bootstrapping the setup of a new
machine.

The first thing the script does is set some flags for exiting and
debugging:

#+BEGIN_SRC sh
  # -*- coding: utf-8; mode: sh; -*-
  # Exit when a command fails
  set -o errexit
  # Exit when a command in a series of pipes fails
  set -o pipefail
  # Exit when there is an undeclared variable
  set -o nounset
  # Trace what gets executed (for debugging)
  #set -o xtrace
#+END_SRC

Let's run the rest of the script from the home directory:

#+BEGIN_SRC sh
  cd "${HOME}"
#+END_SRC

Next, let's have the script detect the operating system.

#+BEGIN_SRC sh
  if [[ $OSTYPE == darwin* ]]; then
      BASH_OS_TYPE='macOS'
  elif [[ $OSTYPE == linux-gnu ]]; then
      BASH_OS_TYPE='Linux'
  elif [[ '$OS' == Windows* ]]; then
      BASH_OS_TYPE='Windows'
  else
      BASH_OS_TYPE='Unknown'
  fi
#+END_SRC

Then, based on the OS, it installs and/or updates the package manager.
Using the package manager, it also installs both Emacs and =git=, which
will allow for programatically setting up the rest of my configuration.

#+BEGIN_SRC sh
  if [[ $BASH_OS_TYPE == macOS ]]; then
      if type brew >/dev/null 2>&1; then
          echo "Homebrew is already installed ..."
      else
          /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
      fi
      brew update && brew upgrade
      brew tap caskroom/cask
      brew cask install emacs
      brew install git
  elif [[ $BASH_OS_TYPE == Linux ]]; then
      sudo apt-get update -y && sudo apt-get upgrade -y
      sudo apt-get install -y emacs
      sudo apt-get install -y git
  fi
#+END_SRC

Next, the script clones [[https://github.com/adamliter/config-files][the repository that contains my configuration
files]] into =${HOME}/config-files=. If that file already exists, the
~git clone~ command will fail, so I remove it first just to be cautious,
but this should be unnecessary if this is a new machine.

In the case that this is not a new machine, the command ~rm -rf
"${HOME}/config-files"~ will remove the file =~/.ssh/config=, since that
file is a symlink that points inside of the =git= repository. This will
cause the =bootstrap.sh= script to fail since the submodules in the
repository make use of the SSH hosts defined in the SSH config
file. Thus, in order to ensure that this =bootstrap.sh= script can also
be run on a machine that is already setup (to, for example, reset how
everything is configured or apply new changes), we want to ensure that
those SSH hosts still exist when this script tries to clone the repo and
its submodules.

#+BEGIN_SRC sh
  if [ -f "${HOME}/.ssh/config" ]; then
      cp -H "${HOME}/.ssh/config" "${HOME}/.ssh/config.temp"
      rm "${HOME}/.ssh/config"
      mv "${HOME}/.ssh/config.temp" "${HOME}/.ssh/config"
  fi
  rm -rf "${HOME}/config-files"
  git clone github:adamliter/config-files.git "${HOME}/config-files"
#+END_SRC

After cloning, it updates all submodules. Submodules, as always, are a
bit tricky. ~git submodule update --init --recursive~ will recursively
initialize and update all submodules in the =git= repo. Moreover, with
the ~--remote~ flag, any submodules that are specified to track a branch
on the remote will be fast-forwarded to the most recent commit on that
branch on the remote, regardless of the status of the submodule in the
parent repo. Furthermore, since [[https://stackoverflow.com/a/20797186/2571049][submodules are always checked out in a
detached HEAD state]], the script also checks out either the branch that
the submodule is set up to track on the remote or the master branch for
all submodules.

#+BEGIN_SRC sh
  cd "${HOME}/config-files"
  git submodule update --init --remote --recursive

  git submodule foreach --recursive \
    'git checkout \
    $(git config -f $toplevel/.gitmodules submodule.$name.branch || \
    echo master)'
#+END_SRC

After all the futzing around with submodules, it symlinks some things
into place.

#+BEGIN_SRC sh
  rm -rf "${HOME}/.emacs.d"
  ln -sn "${HOME}/config-files/emacs.d" "${HOME}/.emacs.d"
#+END_SRC

Next, the script evaluates my =init.el= file in order to bootstrap the
installation of all of the Emacs packages that I use. The ~--batch~
option to ~emacs~ prevents Emacs from being opened as en
editor. Instead, it just evaluates the file specified by ~--load~.

#+BEGIN_SRC sh
  emacs --batch --load="${HOME}/.emacs.d/init.el"
#+END_SRC

Finally, the script evaluates all source code blocks in the file
=${HOME}/config-files/README.org= where ~:eval yes~ as well as tangling
the file in order to put all other configuration information in the
proper locations.

#+BEGIN_SRC sh
  emacs --batch \
    --eval="(progn
    (require 'org)
    (setq org-confirm-babel-evaluate nil)
    (find-file \"~/config-files/README.org\")
    (org-babel-tangle)
    (org-babel-execute-buffer)
    (kill-buffer))"
#+END_SRC

* Command line utilities

This section of this =org= document both installs the relevant command
line utility (if it is not already installed) and creates the
appropriate configuration files for that utility, if necessary. Even
though all of the configuration files are derived files, they are all
kept under version control and symlinked into the appropriate
locations. Doing so allows me to more readily notice any external
programs or utilities that change my configuration files, as it will
lead to a dirty working tree in =git=.

** All OSes

*** bash

**** Installation
     :PROPERTIES:
     :header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
     :END:

The version of bash that ships on macOS is pretty outdated, so let's
install a more recent version via Homebrew. In order to use this newer
version of bash as the login shell, it needs to be added to the file
=/etc/shells=. Then, the shell can be changed to =/usr/local/bin/bash=
for the current user. In order for this to take effect, I log back in.

#+BEGIN_SRC sh
  if [[ $BASH_OS_TYPE == macOS ]]; then
      brew update && brew install bash
      if ! grep -q "/usr/local/bin/bash" /etc/shells; then
          echo "Adding Homebrew's bash to possible login shells ..."
          sudo bash -c "echo /usr/local/bin/bash >> /etc/shells"
      else
          echo "Homebrew's bash is already a possible login shell ..."
      fi
      if [ $SHELL == "/usr/local/bin/bash" ]; then
          echo "Shell is already set to Homebrew's bash ..."
      else
          echo "Setting shell to Homebrew's bash ..."
          chsh -s /usr/local/bin/bash
      fi
  fi
#+END_SRC

**** Configuration

References:

- [[https://superuser.com/q/183870/756208][Difference between .bashrc and .bash_profile]]
- [[https://superuser.com/q/789448/756208][Choosing between .bashrc, .profile, .bash_profile, etc]]

***** =~/.bash_profile=
      :PROPERTIES:
      :header-args:sh: :eval no :exports code :tangle ~/config-files/bash/bash_profile :mkdirp yes :padline no
      :END:

Login shells (/e.g./ a shell that you start from a non-graphical desktop
environment, like when logging into a machine via SSH) read one of three
files (assuming your shell is bash):

1. =~/.bash_profile=
2. =~/.bash_login=
3. =~/.profile=

Whichever file is found first is the one that gets read, and the shell
stops looking for the others. Furthermore, login shells do *not* read
=~/.bashrc=, but the best practice is to have an *interactive* login
shell read =~/.bashrc=. Ensuring that this happens is done by adding the
following to the =~/.bash_profile= file:

#+BEGIN_SRC sh
  # -*- mode: sh; fill-column: 72; coding: utf-8 -*-
  if [ -f "${HOME}/.bashrc" ] && [[ $- == *i* ]]; then
      source "${HOME}/.bashrc"
  fi
#+END_SRC

It's worth noting that on macOS, unlike on Linux, all shells started
from Terminal.app (or iTerm.app) in a graphical environment are started
as login shells and thus read =~/.bash_profile= (instead of =~/.bashrc=,
which is what is read when starting Terminal in a graphical desktop
environment on Linux, since it is a non-login shell). Thus, if you want
anything in your =~/.bashrc= to be read when using macOS, you certainly
need to make sure that =~/.bash_profile= sources =~/.bashrc=.

At any rate, this can now be symlinked into the appropriate location,
after it is tangled:

#+BEGIN_SRC sh :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
  ln -sf "${HOME}/config-files/bash/bash_profile" "${HOME}/.bash_profile"
#+END_SRC

***** =~/.bashrc=
      :PROPERTIES:
      :header-args:sh: :eval no :exports code :tangle ~/config-files/bash/bashrc :mkdirp yes :padline no
      :END:

In the =~/.bashrc= file, I want to ensure that the system-wide =bashrc=
file is read, if it exists. On macOS, this usually exists as
=/etc/bashrc=.

#+BEGIN_SRC sh
  if [ -f /etc/bashrc ]; then
      source /etc/bashrc
  fi
#+END_SRC

And, on Ubuntu, this usually exists as =/etc/bash.bashrc=.

#+BEGIN_SRC sh
  if [ -f /etc/bash.bashrc ]; then
      source /etc/bash.bashrc
  fi
#+END_SRC

While it is not considered best practice to source =~/.profile= from
inside of =~/.bashrc= (in particular, see [[https://superuser.com/a/183980/756208][Gilles's answer]] to [[https://superuser.com/q/183870/756208][Difference
between .bashrc and .bash_profile]]), I'm going to go ahead and do this
anyway because it makes life easier, and I have yet to encounter any
problems because of it. The recommended best practice is to source
=~/.basrhc= and =~/.profile= from =~/.bash_profile=, in that
order. However, for the reasonos mentioned above when discussing macOS
shells started in the graphical desktop environment, most shells started
in a graphical desktop environment will only read =~/.bashrc= because
they are non-login shells. However, this means that environment
variables that are set in =~/.profile= will not be available in these
shells. So I'll flout the best practice for now, until I run into
problems because of it.

#+BEGIN_SRC sh
  if [ -f "${HOME}/.profile" ]; then
      source "${HOME}/.profile"
  fi
#+END_SRC

****** Aliases

Always gotta shrug:

#+BEGIN_SRC sh
  alias eh="echo ¯\\\_\(ツ\)_/¯ | pbcopy"
  alias ehh="eh"
#+END_SRC

Some aliases for changing directories:

#+BEGIN_SRC sh
  alias .1='cd ..'
  alias ..='cd ..'
  alias .2='cd ../..'
  alias ....='cd ../..'
  alias .3='cd ../../..'
  alias .4='cd ../../../..'
  alias .5='cd ../../../../..'
#+END_SRC

List all the things:

#+BEGIN_SRC sh
  alias l='ls -aF'
  alias ll='ls -alF'

  # list only hidden directories and files
  alias l.='ls -dF .*'
  alias ll.'=ls -ldF .*'
#+END_SRC

To ensure the availability of 256 colors in =tmux= (see [[https://stackoverflow.com/a/10163861/2571049][this answer]] to
[[https://stackoverflow.com/q/10158508/2571049][lose vim colorscheme in tmux mode]]).

#+BEGIN_SRC sh
  alias tmux='tmux -2'
#+END_SRC

Some =gpg= aliases:

#+BEGIN_SRC sh
  alias gpg='gpg2'
  alias gpgusb='gpg2 --home=/Volumes/adamliter/.gnupg'
#+END_SRC

Some macOS-specific aliases:

#+BEGIN_SRC sh
  if [[ $OSTYPE == darwin* ]]; then
      alias tw='open -a "TextWrangler"'
      alias showFiles='defaults write com.apple.finder AppleShowAllFiles \
  YES; killall Finder'
      alias hideFiles='defaults write com.apple.finder AppleShowAllFiles NO; \
  killall Finder'
  fi
#+END_SRC

Some aliases for Homebrew:

#+BEGIN_SRC sh
  if type brew >/dev/null 2>&1; then
      alias bud='brew update -v'
      alias bug='brew upgrade  -v'
      alias brc='brew cleanup -v'
      alias brp='brew prune -v'
      alias bra='bud && bug && brc && brp'
  fi
#+END_SRC

An SSH alias for =ssh-add=:

#+BEGIN_SRC sh
  alias sshid='ssh-add ~/.ssh/id_rsa'
#+END_SRC

Some aliases for =pass=:

#+BEGIN_SRC sh
  alias ppass='PASSWORD_STORE_DIR=~/.password-store/personal/ pass'
  alias pp='ppass'

  # lingbib password store
  alias lb-pass='PASSWORD_STORE_DIR=~/.password-store/shared-projects\
  /lingbib/ pass'

  # common logins
  alias amazon='pp -c misc/amazon'
  alias amex='pp -c finances/amex'
  alias bb='pp -c misc/bitbucket'
  alias chess='pp -c misc/chess'
  alias delta='pp -c travel/delta'
  alias fmail='pp -c email/fastmail/password'
  alias kb='pp -c keybase/passphrase'
  alias msufcu='pp -c finances/msufcu'
#+END_SRC

Some aliases for Emacs:

#+BEGIN_SRC sh
  alias e='emacsclient -t -a=""'
#+END_SRC

Some aliases for =git= and =hub=:

#+BEGIN_SRC sh
  if type hub >/dev/null 2>&1; then
      alias git='hub'
  fi
  alias g='git status -sb'
  alias gp='git pull'
  alias gpr='git pull --rebase'
  alias gpp='git pull --rebase && git push'
  alias ga='git add'
  alias gc='git commit'
  alias gcn='git commit --no-edit'
  alias gce='git commit -e'
  alias gces='git commit -eS'
  alias gca='git commit --amend'
  alias gcah='git commit --amend -C HEAD'
  alias gcv='git commit --no-verify'
  alias gdv='git diff'
  alias gdc='git diff --cached'
  alias gl='git log --oneline --decorate --graph'
  alias gla='git log --oneline --decorate --graph --all'
  alias gt='git tag'
  alias grc='git rebase --continue'
  alias gsl='git stash list'
  alias gss='git stash save'
#+END_SRC

Some aliases for some common directories:

#+BEGIN_SRC sh
  if type brew >/dev/null 2>&1; then
      alias cdcbrew='cd $(brew --repository homebrew/core)'
  fi
  alias cdpsite='cd ~/projects/website-src'
  alias cdtex='cd ~/Dropbox/TeXnology'
  alias cdlingsem='cd ~/Dropbox/TeXnology/lingsem'
  alias cdconfig='cd ~/config-files'
  alias cdcv='cd ~/Dropbox/SillyCareerStuff/adamlitercv'
  alias cdresume='cd ~/Dropbox/SillyCareerStuff/adamliterresume'
  alias cdling='cd ~/Dropbox/linguistics'
  alias cdugradthesis='cd ~/Dropbox/linguistics/undergrad-thesis'
  alias cdmastersthesis='cd ~/Dropbox/linguistics/masters-thesis'
  alias cdemacs='cd ~/config-files/.emacs.d'
#+END_SRC

An alias for using CorpusSearch:

#+BEGIN_SRC sh
  if [ -f "${HOME}/Applications/CS_2.003.04.jar" ]; then
      alias CS='java -classpath ~/Applications/CS_2.003.04.jar \
  csearch/CorpusSearch'
  fi
#+END_SRC

****** Auto completion

Tab auto completion for =git= and =hub=:

#+BEGIN_SRC sh
  if [ -f /usr/local/etc/bash_completion.d/git-completion.bash ]; then
      source /usr/local/etc/bash_completion.d/git-completion.bash
  fi

  if [ -f /usr/local/etc/bash_completion.d/hub.bash_completion.sh ]; then
      source /usr/local/etc/bash_completion.d/hub.bash_completion.sh
  fi
#+END_SRC

Tab auto completon for pandoc:

#+BEGIN_SRC sh
  if [ -f /usr/local/etc/bash_completion.d/pandoc ]; then
      source /usr/local/etc/bash_completion.d/pandoc
  fi
#+END_SRC

Tab auto completion for Django:

#+BEGIN_SRC sh
  if [ -f /usr/local/etc/bash_completion.d/django ]; then
      source /usr/local/etc/bash_completion.d/django
  fi
#+END_SRC

Tab auto completion for Homebrew:

#+BEGIN_SRC sh
  if [ -f /usr/local/etc/bash_completion.d/brew ]; then
      source /usr/local/etc/bash_completion.d/brew
  fi
#+END_SRC

Tab auto completion for =tmux=:

#+BEGIN_SRC sh
  if [ -f /usr/local/etc/bash_completion.d/tmux ]; then
      source /usr/local/etc/bash_completion.d/tmux
  fi
#+END_SRC

Tab auto completion for =pass=:

#+BEGIN_SRC sh
  if [ -f /usr/local/etc/bash_completion.d/pass ]; then
      source /usr/local/etc/bash_completion.d/pass
  fi
  # personal completion
  _ppass(){
      PASSWORD_STORE_DIR=~/.password-store/personal/ _pass
  }

  complete -o filenames -o nospace -F _ppass ppass

  _pp(){
      _ppass
  }

  complete -o filenames -o nospace -F _pp pp

  # lingbib completion
  _lb-pass(){
      PASSWORD_STORE_DIR=~/.password-store/shared-projects/lingbib/ _pass
  }

  complete -o filenames -o nospace -F _lb-pass lb-pass
#+END_SRC

****** Prompt

First, let's set up some more useful ways to refer to colors:

#+BEGIN_SRC sh
  RED="\[\e[31m\]"
  LIGHT_RED="\[\e[91m\]"
  GREEN="\[\e[32m\]"
  LIGHT_GREEN="\[\e[92m\]"
  YELLOW="\[\e[33m\]"
  LIGHT_YELLOW="\[\e[93m\]"
  BLUE="\[\e[34m\]"
  LIGHT_BLUE="\[\e[94m\]"
  MAGENTA="\[\e[35m\]"
  LIGHT_MAGENTA="\[\e[95m\]"
  CYAN="\[\e[36m\]"
  LIGHT_CYAN="\[\e[96m\]"
  LIGHT_GREY="\[\e[37m\]"
  LIGHT_GRAY="\[\e[37m\]"
  WHITE="\[\e[97m\]"
  COLOR_RESET="\[\e[0m\]"
#+END_SRC

Next, let's define a separator to separate information in the prompt:

#+BEGIN_SRC sh
  MY_PS1_SEP=" ${WHITE}█${COLOR_RESET} "
#+END_SRC

Next, let's write a function to determine if the current directory is a
=git= repo:

#+BEGIN_SRC sh
  function is_git_repository {
      git branch > /dev/null 2>&1
  }
#+END_SRC

If it is, we'll want to determine some information about it:

#+BEGIN_SRC sh
  function set_git_branch {
      # Capture the output of the "git status" command.
      git_status="$(git status 2> /dev/null)"

      # Set color based on clean/staged/dirty
      clean_pattern="working (tree|directory) clean"
      if [[ ${git_status} =~ ${clean_pattern} ]]; then
          state="${LIGHT_GREEN}"
      elif [[ ${git_status} =~ "Changes to be committed" ]]; then
          state="${LIGHT_YELLOW}"
      else
          state="${RED}"
      fi

      # Set arrow icon based on status against remote.
      remote_pattern="(# )?Your branch is (ahead of|behind)"
      if [[ ${git_status} =~ ${remote_pattern} ]]; then
          if [[ ${BASH_REMATCH[2]} == "ahead of" ]]; then
              remote="↑"
          else
              remote="↓"
          fi
      else
          remote=""
      fi
      diverge_pattern="(# )?Your branch and (.*) have diverged"
      if [[ ${git_status} =~ ${diverge_pattern} ]]; then
          remote="↕"
      fi

      # Get the name of the branch.
      branch_pattern="^(# )?On branch ([^${IFS}]*)"
      if [[ ${git_status} =~ ${branch_pattern} ]]; then
          branch=${BASH_REMATCH[2]}
      fi

      # Set the final branch string.
      BRANCH="${MY_PS1_SEP}${state}(${branch})${remote}${COLOR_RESET}"
  }
#+END_SRC

Additionally, if this is also a Python virtual environment, we'll want
to add some information about that to the prompt:

#+BEGIN_SRC sh
  function set_virtualenv () {
      if test -z "$VIRTUAL_ENV"; then
          MY_VENV=""
      else
          MY_VENV="${LIGHT_GREY}[${VIRTUAL_ENV##*/}]${COLOR_RESET}\
  ${MY_PS1_SEP}"
      fi
  }
#+END_SRC

We can also change the color of the prompt symbol, based on the exit
code of the last command. Here's a function to get and set that
information:

#+BEGIN_SRC sh
  function set_prompt_symbol () {
      if test $1 -eq 0 ; then
          PROMPT_SYMBOL="\$"
      else
          PROMPT_SYMBOL="${RED}\$${COLOR_RESET}"
      fi
  }
#+END_SRC

I'd also like to shorten the path to the current working directory in
the prompt if there isn't enough room to display it in the shell. In
order to do this, I need to first compute the prompt minus the working
directory in order to determine the number of remaining columns that I
have left to work with:

#+BEGIN_SRC sh
  strip_color () {
      COLOR_REGEX='s/\\\[\\e\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]\\\]//g'
      if [[ $OSTYPE == darwin* ]]; then
          sed -Ee $COLOR_REGEX <<< """$1"""
      else
          sed -re $COLOR_REGEX <<< """$1"""
      fi
  }

  get_ps1_less_pwd () {
      PS1_LESS_PWD=$(printf "%s%s%s%s" \
                            "$(strip_color "${MY_VENV}")" \
                            "$(whoami)@$(hostname -s)" \
                            "$(strip_color "${MY_PS1_SEP}")" \
                            "$(strip_color "${BRANCH}")")
  }
#+END_SRC

Now I can finally declare the function to actually compute and calculate
the bash prompt:

#+BEGIN_SRC sh
  function set_bash_prompt () {
      # Set the PROMPT_SYMBOL variable. We do this first so we don't lose the
      # return value of the last command.
      set_prompt_symbol $?

      # Get virtualenv info
      set_virtualenv

      # Set the BRANCH variable.
      if is_git_repository ; then
          set_git_branch
      else
          BRANCH=''
      fi

      # get PS1_LESS_PWD to calculate length remaining
      get_ps1_less_pwd

      # get truncated PWD
      # loosely based on http://stackoverflow.com/a/26555347/2571049
      MY_PWD=$(pwd | awk -F/ -v "u=$PS1_LESS_PWD" -v "n=$(tput cols)" \
                         -v "h=^$HOME" \
                         '{sub(h,"~"); u=length(u); n=n-u-1; b=$1} \
                         length($0)<=n || NF==2 {print; next;} \
                         NF>2 {b=b"/.../"; e=$NF; n-=length(b $NF); \
                         for (i=NF-1; i>2 && n>length(e $i)+1; i--) e=$i"/"e;} {print b e;}')

      # Set the bash prompt variable.
      PS1="
  ${MY_VENV}\
  ${WHITE}\u${COLOR_RESET}\
  ${LIGHT_GREEN}@${COLOR_RESET}\
  ${LIGHT_MAGENTA}\h${COLOR_RESET}\
  ${MY_PS1_SEP}\
  ${LIGHT_CYAN}${MY_PWD}${COLOR_RESET}\
  ${BRANCH}
  ${PROMPT_SYMBOL} "
  }
#+END_SRC

And, finally, we can actually call the function to set the prompt:

#+BEGIN_SRC sh
  PROMPT_COMMAND=set_bash_prompt
#+END_SRC

****** Colors

See [[https://apple.stackexchange.com/q/33677/85567][How can I configure Mac Terminal to have color ls output?]]

#+BEGIN_SRC sh
  export CLICOLOR=1
  export LSCOLORS=gxBxhxDxfxhxhxhxhxcxcx
#+END_SRC

****** Some Python stuff

#+BEGIN_SRC sh
  source /usr/local/bin/virtualenvwrapper.sh

  gpip2(){
      PIP_REQUIRE_VIRTUALENV="" pip2 "$@"
  }

  gpip3(){
      PIP_REQUIRE_VIRTUALENV="" pip3 "$@"
  }
#+END_SRC

Finally, =~/.bashrc= can be symlinked into the appropriate location,
after it is tangled:

#+BEGIN_SRC sh :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
  ln -sf "${HOME}/config-files/bash/bashrc" "${HOME}/.bashrc"
#+END_SRC

***** =~/.profile=
      :PROPERTIES:
      :header-args:sh: :eval no :exports code :tangle ~/config-files/bash/profile :mkdirp yes :padline no
      :END:

=~/.profile= is where stuff that is not bash-specifc goes, such as
environment variables.

#+BEGIN_SRC sh
  # -*- mode: sh; fill-column: 72; coding: utf-8 -*-

  if [[ ":${PATH}:" != *":${HOME}/bin:"* ]] && [ -d "${HOME}/bin" ]; then
      export PATH="${HOME}/bin:${PATH}"
  fi

  # This should come at the end of any path stuff,
  # otherwise the rvm-managed version of Ruby
  # will not be at the beginning of the path, and rvm
  # will complain about this

  [[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm" # Load RVM into a shell session *as a function*

  export PATH="$PATH:$HOME/.rvm/bin" # Add RVM to PATH for scripting

  # ----------------------------------------------------------------------
  # EDITOR
  # ----------------------------------------------------------------------
  export EDITOR=/usr/local/bin/ec
  export ALTERNATE_EDITOR=""

  # ----------------------------------------------------------------------
  # Python stuff
  # ----------------------------------------------------------------------
  export PIP_REQUIRE_VIRTUALENV=true
  export VIRTUALENVWRAPPER_PYTHON=$(which python3)
  export PROJECT_HOME=$HOME/projects
  export WORKON_HOME=$HOME/.virtualenvs
  export VIRTUAL_ENV_DISABLE_PROMPT=1

#+END_SRC

Finally, =~/.profile= can be symlinked into the appropriate location,
after it is tangled:

#+BEGIN_SRC sh :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
  ln -sf "${HOME}/config-files/bash/profile" "${HOME}/.profile"
#+END_SRC

*** curl

**** Installation
     :PROPERTIES:
     :header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
     :END:

~curl~ is installed by default on macOS but not on Linux:

#+BEGIN_SRC sh
  if [[ $BASH_OS_TYPE == Linux ]]; then
      sudo apt-get install -y curl
  fi
#+END_SRC

*** git

**** Installation

=git= is already installed earlier in the bootstrapping process.

**** Configuration

***** =~/.gitconfig=
      :PROPERTIES:
      :header-args:sh: :eval no :exports code :tangle "~/config-files/git/gitconfig" :mkdirp yes :padline no
      :END:

****** =[user]=

=git= needs to know who I am.

#+BEGIN_SRC sh
  # -*- coding: utf-8; mode: conf; fill-column: 72; -*-
  [user]
      name = Adam Liter
      email = io@adamliter.org
      signkey = 0x98723A2089026CD6
#+END_SRC

****** =[core]=

Set up my editor for =git= and a global ignore file.

#+BEGIN_SRC sh
  [core]
      editor = "emacsclient -t -a=''"
      excludesfile = ~/.gitignore_global
#+END_SRC

****** =[color]=

This sets up some defaults for displaying color with =git=.

#+BEGIN_SRC sh
  [color]
      diff = auto
      status = auto
      branch = auto
      interactive = auto
      ui = true
      pager = true
#+END_SRC

****** =[alias]=

This sets up an alias for automatically pushing submodules.

#+BEGIN_SRC sh
  [alias]
      pushall = push --recurse-submodule=on-demand
#+END_SRC

****** =[push]=

The following sets the default behavior of ~git push~ such that it only
pushes the current branch to the remote repo. For further discussion,
see either of the following questions on Stack Overflow:

- [[https://stackoverflow.com/q/23918062/2571049]["simple" vs "current" push.default in git for decentralized workflow]]
- [[https://stackoverflow.com/q/13148066/2571049][Warning: push.default is unset; its implicit value is changing in Git 2.0]]

#+BEGIN_SRC sh
  [push]
      default = simple
#+END_SRC

****** =[pull]=

=git pull= should rebase by default. In versions of =git= older than
1.8.5, this can be achieved by setting the configuration option
=pull.rebase= to =true=. In =git= 1.8.5 and more recent versions, it
became possible to set the configuration option =pull.rebase= to
=preserve= (see [[https://github.com/git/git/blob/a194eaddca201163aa756faccd519f056bd3c35e/Documentation/RelNotes/1.8.5.txt#L66-L68][here]]). This is better because it runs ~git pull
--preserve-merges~ instead of ~git pull --rebase~. The use case for this
is that if you are working locally and do a non-fast-forward merge of
your feature branch into the master branch but then need to pull in
changes from the upstream master branch before being able to push, the
~git pull --rebase~ would flatten the non-fast-forward merge that you
just did, whereas ~git pull --preserve-merges~ will preserve that merge
commit.

#+BEGIN_SRC sh
  [pull]
      rebase = preserve
#+END_SRC

****** =[gpg]=

For =gpg= stuff with =git=, use =gpg2=.

#+BEGIN_SRC sh
  [gpg]
      program = gpg2
#+END_SRC

****** Symlink into place

Finally, the =gitconfig= file needs to be symlinked into the proper
location.

#+BEGIN_SRC sh :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
  ln -sf "${HOME}/config-files/git/gitconfig" "${HOME}/.gitconfig"
#+END_SRC

***** =~/.gitignore_global=
      :PROPERTIES:
      :header-args:sh: :eval no :exports code :tangle ~/config-files/git/gitignore_global :mkdirp yes :padline no
      :END:

A good reference for all sorts of patterns that =git= ought to ignore is
[[https://github.com/github/gitignore][=github/gitingore=]].

The following things are things that I have =git= ignore by default
globally.

****** macOS

Some stuff to ignore on macOS, taken from [[https://github.com/github/gitignore/blob/master/Global/macOS.gitignore][=github/gitignore=]]. However, I
haven't added the Icon ignore pattern because [[https://superuser.com/a/298798/756208][it needs to end with a
carriage return]], and I have Emacs set up to trim trailing white
space. I'd rather not disable that for this document just to be able to
add this ignore pattern, since it is a pretty uncommon pattern and
largely only occurs in the top-level directories of the folders
associated with services like Dropbox or Google Drive (I don't generally
change/set a directory's icon).

#+BEGIN_SRC sh
  # -*- coding: utf-8; fill-column: 72; mode: conf; -*-
  ,*.DS_Store
  .AppleDouble
  .LSOverride

  # Thumbnails
  ._*

  # Files that might appear in the root of a volume
  .DocumentRevisions-V100
  .fseventsd
  .Spotlight-V100
  .TemporaryItems
  .Trashes
  .VolumeIcon.icns
  .com.apple.timemachine.donotpresent

  # Directories potentially created on remote AFP share
  .AppleDB
  .AppleDesktop
  Network Trash Folder
  Temporary Items
  .apdisk
#+END_SRC

****** Linux

The following is stuff to ignore on Linux, taken from
[[https://github.com/github/gitignore/blob/master/Global/Linux.gitignore][=github/gitignore=]].

#+BEGIN_SRC sh
  # temporary files which can be created if a
  # process still has a handle open of a deleted file
  .fuse_hidden*

  # KDE directory preferences
  .directory

  # Linux trash folder which might appear on any partition or disk
  .Trash-*

  # .nfs files are created when an open file
  # is removed but is still being accessed
  .nfs*
#+END_SRC

****** Windows

The following is stuff to ignore in Windows, taken from
[[https://github.com/github/gitignore/blob/master/Global/Windows.gitignore][=github/gitingore=]].

#+BEGIN_SRC sh
  # Windows image file caches
  Thumbs.db
  ehthumbs.db

  # Dump file
  ,*.stackdump

  # Folder config file
  Desktop.ini

  # Recycle Bin used on file shares
  $RECYCLE.BIN/

  # Windows Installer files
  ,*.cab
  ,*.msi
  ,*.msm
  ,*.msp

  # Windows shortcuts
  ,*.lnk
#+END_SRC

****** Emacs

The following is Emacs stuff to ignore, taken from [[https://github.com/github/gitignore/blob/master/Global/Emacs.gitignore][=github/gitignore=]].

#+BEGIN_SRC sh
  ,*~
  \#*\#
  /.emacs.desktop
  /.emacs.desktop.lock
  ,*.elc
  auto-save-list
  tramp
  .\#*

  # Org-mode
  .org-id-locations
  ,*_archive

  # flymake-mode
  ,*_flymake.*

  # eshell files
  ,**/eshell/history
  ,**/eshell/lastdir

  # elpa packages
  /elpa/

  # reftex files
  ,*.rel

  # AUCTeX auto folder
  ,**/auto/

  # cask packages
  .cask/
  dist/

  # Flycheck
  flycheck_*.el

  # server auth directory
  /server/

  # projectiles files
  .projectile

  # directory configuration
  .dir-locals.el
#+END_SRC

****** TeX

The following is stuff to ignore for (La)TeX, taken from
[[https://github.com/github/gitignore/blob/master/TeX.gitignore][=github/gitignore=]].

#+BEGIN_SRC sh
  ## Core latex/pdflatex auxiliary files:
  ,*.aux
  ,*.lof
  ,*.log
  ,*.lot
  ,*.fls
  ,*.out
  ,*.toc
  ,*.fmt
  ,*.fot
  ,*.cb
  ,*.cb2

  ## Intermediate documents:
  ,*.dvi
  ,*-converted-to.*
  # these rules might exclude image files for figures etc.
  # *.ps
  # *.eps
  # *.pdf

  ## Generated if empty string is given at "Please type another file name for output:"
  .pdf

  ## Bibliography auxiliary files (bibtex/biblatex/biber):
  ,*.bbl
  ,*.bcf
  ,*.blg
  ,*-blx.aux
  ,*-blx.bib
  ,*.brf
  ,*.run.xml

  ## Build tool auxiliary files:
  ,*.fdb_latexmk
  ,*.synctex
  ,*.synctex(busy)
  ,*.synctex.gz
  ,*.synctex.gz(busy)
  ,*.pdfsync

  ## Auxiliary and intermediate files from other packages:
  # algorithms
  ,*.alg
  ,*.loa

  # achemso
  acs-*.bib

  # amsthm
  ,*.thm

  # beamer
  ,*.nav
  ,*.snm
  ,*.vrb

  # changes
  ,*.soc

  # cprotect
  ,*.cpt

  # elsarticle
  ,*.spl

  # endnotes
  ,*.ent

  # fixme
  ,*.lox

  # feynmf/feynmp
  ,*.mf
  ,*.mp
  ,*.t[1-9]
  ,*.t[1-9][0-9]
  ,*.tfm

  #(r)(e)ledmac/(r)(e)ledpar
  ,*.end
  ,*.?end
  ,*.[1-9]
  ,*.[1-9][0-9]
  ,*.[1-9][0-9][0-9]
  ,*.[1-9]R
  ,*.[1-9][0-9]R
  ,*.[1-9][0-9][0-9]R
  ,*.eledsec[1-9]
  ,*.eledsec[1-9]R
  ,*.eledsec[1-9][0-9]
  ,*.eledsec[1-9][0-9]R
  ,*.eledsec[1-9][0-9][0-9]
  ,*.eledsec[1-9][0-9][0-9]R

  # glossaries
  ,*.acn
  ,*.acr
  ,*.glg
  ,*.glo
  ,*.gls
  ,*.glsdefs

  # gnuplottex
  ,*-gnuplottex-*

  # gregoriotex
  ,*.gaux
  ,*.gtex

  # hyperref
  ,*.brf

  # knitr
  ,*-concordance.tex
  # TODO Comment the next line if you want to keep your tikz graphics files
  ,*.tikz
  ,*-tikzDictionary

  # listings
  ,*.lol

  # makeidx
  ,*.idx
  ,*.ilg
  ,*.ind
  ,*.ist

  # minitoc
  ,*.maf
  ,*.mlf
  ,*.mlt
  ,*.mtc[0-9]*
  ,*.slf[0-9]*
  ,*.slt[0-9]*
  ,*.stc[0-9]*

  # minted
  _minted*
  ,*.pyg

  # morewrites
  ,*.mw

  # nomencl
  ,*.nlo

  # pax
  ,*.pax

  # pdfpcnotes
  ,*.pdfpc

  # sagetex
  ,*.sagetex.sage
  ,*.sagetex.py
  ,*.sagetex.scmd

  # scrwfile
  ,*.wrt

  # sympy
  ,*.sout
  ,*.sympy
  sympy-plots-for-*.tex/

  # pdfcomment
  ,*.upa
  ,*.upb

  # pythontex
  ,*.pytxcode
  pythontex-files-*/

  # thmtools
  ,*.loe

  # TikZ & PGF
  ,*.dpth
  ,*.md5
  ,*.auxlock

  # todonotes
  ,*.tdo

  # easy-todo
  ,*.lod

  # xindy
  ,*.xdy

  # xypic precompiled matrices
  ,*.xyc

  # endfloat
  ,*.ttt
  ,*.fff

  # Latexian
  TSWLatexianTemp*

  ## Editors:
  # WinEdt
  ,*.bak
  ,*.sav

  # Texpad
  .texpadtmp

  # Kile
  ,*.backup

  # KBibTeX
  ,*~[0-9]*

  # auto folder when using emacs and auctex
  /auto/*
#+END_SRC

****** Python

The following is stuff to ignore for Python, taken from
[[https://github.com/github/gitignore/blob/master/Python.gitignore][=github/gitignore=]].

#+BEGIN_SRC sh
  # Byte-compiled / optimized / DLL files
  __pycache__/
  ,*.py[cod]
  ,*$py.class

  # C extensions
  ,*.so

  # Distribution / packaging
  .Python
  build/
  develop-eggs/
  dist/
  downloads/
  eggs/
  .eggs/
  lib/
  lib64/
  parts/
  sdist/
  var/
  wheels/
  ,*.egg-info/
  .installed.cfg
  ,*.egg

  # PyInstaller
  #  Usually these files are written by a python script from a template
  #  before PyInstaller builds the exe, so as to inject date/other infos into it.
  ,*.manifest
  ,*.spec

  # Installer logs
  pip-log.txt
  pip-delete-this-directory.txt

  # Unit test / coverage reports
  htmlcov/
  .tox/
  .coverage
  .coverage.*
  .cache
  nosetests.xml
  coverage.xml
  ,*.cover
  .hypothesis/

  # Translations
  ,*.mo
  ,*.pot

  # Django stuff:
  ,*.log
  local_settings.py

  # Flask stuff:
  instance/
  .webassets-cache

  # Scrapy stuff:
  .scrapy

  # Sphinx documentation
  docs/_build/

  # PyBuilder
  target/

  # Jupyter Notebook
  .ipynb_checkpoints

  # pyenv
  .python-version

  # celery beat schedule file
  celerybeat-schedule

  # SageMath parsed files
  ,*.sage.py

  # virtualenv
  .env
  .venv/
  venv/
  ENV/

  # Spyder project settings
  .spyderproject
  .spyproject

  # Rope project settings
  .ropeproject

  # mkdocs documentation
  /site

  # mypy
  .mypy_cache/
#+END_SRC

****** R

The following is stuff to ignore for R, taken from [[https://github.com/github/gitignore/blob/master/R.gitignore][=github/gitignore=]].

#+BEGIN_SRC sh
  # History files
  .Rhistory
  .Rapp.history

  # Session Data files
  .RData

  # Example code in package build process
  ,*-Ex.R

  # Output files from R CMD build
  /*.tar.gz

  # Output files from R CMD check
  /*.Rcheck/

  # RStudio files
  .Rproj.user/

  # produced vignettes
  vignettes/*.html
  vignettes/*.pdf

  # OAuth2 token, see https://github.com/hadley/httr/releases/tag/v0.3
  .httr-oauth

  # knitr and R markdown default cache directories
  /*_cache/
  /cache/

  # Temporary files created by R markdown
  ,*.utf8.md
  ,*.knit.md
#+END_SRC

****** Symlink into place

Finally, the =gitignore_global= file needs to be symlinked into the
proper location.

#+BEGIN_SRC sh :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
  ln -sf "${HOME}/config-files/git/gitignore_global" "${HOME}/.gitignore_global"
#+END_SRC

*** gpg

*** htop

**** Installation
     :PROPERTIES:
     :header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
     :END:

#+BEGIN_SRC sh
  if [[ $BASH_OS_TYPE == macOS ]]; then
      brew install htop
  elif [[ $BASH_OS_TYPE == Linux ]]; then
      sudo apt-get install -y htop
  fi
#+END_SRC

**** Configuration
     :PROPERTIES:
     :header-args:sh: :eval no :exports code :tangle "~/config-files/htop/htoprc" :mkdirp yes :padline no
     :END:


I don't have any special configuration for =htop=. If I did, it would go
in =$HOME/.config/htop/htoprc=:

#+BEGIN_SRC sh :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
  #ln -sf "${HOME}/config-files/htop/htoprc" "${HOME}/.config/htop/htoprc"
#+END_SRC

*** hub

*** pandoc

**** Installation
     :PROPERTIES:
     :header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
     :END:

#+BEGIN_SRC sh
  if [[ $BASH_OS_TYPE == macOS ]]; then
      brew install pandoc
  elif [[ $BASH_OS_TYPE == Linux ]]; then
      sudo apt-get install -y pandoc
  fi
#+END_SRC

**** Configuration

There is no configuration setup for =pandoc=.

*** password-store

*** ssh

**** Installation

=ssh= is already installed on both macOS and Linux, by default.

**** Configuration
     :PROPERTIES:
     :header-args:emacs-lisp: :eval yes :exports code :results output silent
     :header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
     :END:

My SSH configuration is kept in a submodule hosted by my private =git=
server so as to keep the details of my SSH configuration private. The
following code, which is executed when this file is tangled, will create
my SSH config and then symlink it into the appropriate location.

#+NAME: ssh-config
#+BEGIN_SRC emacs-lisp
  (org-babel-tangle-file "~/config-files/ssh/README.org")
#+END_SRC

#+BEGIN_SRC sh
  ln -sf "${HOME}/config-files/ssh/config" "${HOME}/.ssh/config"
#+END_SRC

*** tmux

**** Installation
     :PROPERTIES:
     :header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
     :END:

Install =tmux=:

#+BEGIN_SRC sh
  if [[ $BASH_OS_TYPE == macOS ]]; then
      brew install tmux
  elif [[ $BASH_OS_TYPE == Linux ]]; then
      sudo apt-get install -y tmux
  fi
#+END_SRC

On Ubuntu, when installing with =apt-get=, the bash completion script is
installed to =/usr/share/doc/tmux/examples/bash_completion_tmux.sh=
instead of installed in the standard bash completion directory of
=/etc/bash_completion.d/=. So, let's symlink it there:

#+BEGIN_SRC sh
  if [[ BASH_OS_TYPE == Linux ]]; then
      if [ -f /usr/share/doc/tmux/examples/bash_completion_tmux.sh ]; then
          echo "Symlinking tmux bash completion into place ..."
          ln -sf "/usr/share/doc/tmux/examples/bash_completion_tmux.sh" "/etc/bash_completion.d/tmux"
      else
          echo "Could not find tmux bash completion file ..."
      fi
  fi

#+END_SRC

**** Configuration
     :PROPERTIES:
     :header-args:sh: :eval no :exports code :tangle ~/config-files/tmux/tmux.conf :mkdirp yes :padline no
     :END:

To ensure that colors work properly, I've followed the suggestion in
[[https://stackoverflow.com/a/22481496/2571049][this answer]] on Stack Overflow.

#+BEGIN_SRC sh
  # -*- coding: utf-8; mode: conf; fill-column: 72 -*-
  set-option -g default-terminal "xterm-256color"
#+END_SRC

The following ensures that the macOS pasteboard is available in =tmux=
sessions. See [[https://github.com/ChrisJohnsen/tmux-MacOSX-pasteboard][the Github repository]] for more information.

#+BEGIN_SRC sh :tangle (when (eq system-type 'darwin) "~/config-files/tmux/tmux.conf")
  set-option -g default-command "reattach-to-user-namespace -l $SHELL"
#+END_SRC

The following allows the =tmux= configuration file to be reloaded.

#+BEGIN_SRC sh
  bind-key r source-file ~/.tmux.conf
#+END_SRC

The following are some key bindings for opening new SSH sessions in
either a new windows, a vertically split window, or a horizontally split
window.

#+BEGIN_SRC sh
  bind-key S   command-prompt -p "host" "new-window -n %1 'ssh %1'"
  bind-key C-S command-prompt -p "host" "split-window -v 'ssh %1'"
  bind-key M-S command-prompt -p "host" "split-window -h 'ssh %1'"
#+END_SRC

The following are some key bindings for opening Emacs in either a new
window, a vertically split window, or a horizontally split window.

#+BEGIN_SRC sh
  bind-key y   new-window -n "emacs"  "emacsclient -nw"
  bind-key C-y split-window -v "emacsclient -nw"
  bind-key M-y split-window -h "emacsclient -nw"
#+END_SRC

The following defines some more intuitive key bindings for splitting a
window and undefines the default key bindings for this.

#+BEGIN_SRC sh
  bind-key | split-window -h
  bind-key - split-window -v
  unbind '"'
  unbind %
#+END_SRC

The following allows for switching between =tmux= panes using just
M-<arrow>, without the =tmux= prefix key.

#+BEGIN_SRC sh
  bind-key -n M-Left select-pane -L
  bind-key -n M-Right select-pane -R
  bind-key -n M-Up select-pane -U
  bind-key -n M-Down select-pane -D
#+END_SRC

And, finally, the following symlinks the configuration file into the
appropriate location.

#+BEGIN_SRC sh :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
  ln -sf "${HOME}/config-files/tmux/tmux.conf" "${HOME}/.tmux.conf"
#+END_SRC

*** tree

This should be installed when =password-store= is installed.

*** wget

**** Installation
     :PROPERTIES:
     :header-args:sh: :eval no :exports code :tangle bootstrap.sh :shebang "#!/usr/bin/env bash" :padline no
     :END:

~wget~ is installed by default on Linux but not on macOS:

#+BEGIN_SRC sh
  if [[ $BASH_OS_TYPE == Linux ]]; then
      sudo apt-get install -y wget
  fi
#+END_SRC

*** xclip

** macOS only

*** reattach-to-user-namespace

** Linux only

There are currently no programs that I use on Linux only.

* Programming languages

** All OSes

*** Python

*** R

*** TeX

** macOS only

** Linux only

* Applications and GUIs

** All OSes

*** Dropbox

*** Firefox

*** Google Chrome

*** Google Drive

*** Handbrake

*** Inkscape

*** LibreOffice

*** MakeMKV

*** ownCloud

*** Plex

*** Praat

*** PsychoPy

*** RStudio

*** Skype

*** Spotify

*** VirtualBox

*** VLC

** macOS only

*** Alfred

*** Flux

*** iTerm2

*** MailMate

*** Skim

*** TextWrangler

*** UnicodeChecker

** Linux only

# Local Variables:
# mode: org
# coding: utf-8
# fill-column: 72
# indent-tabs-mode: nil
# End:
